window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "x4i", "modulename": "x4i", "type": "module", "doc": "<p></p>\n"}, {"fullname": "x4i.endl_Z", "modulename": "x4i.endl_Z", "type": "module", "doc": "<p></p>\n"}, {"fullname": "x4i.endl_Z.endl_nZs", "modulename": "x4i.endl_Z", "qualname": "endl_nZs", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.endl_Z.endl_ZSymbol", "modulename": "x4i.endl_Z", "qualname": "endl_ZSymbol", "type": "function", "doc": "<p></p>\n", "signature": "(Z)", "funcdef": "def"}, {"fullname": "x4i.endl_Z.endl_SymbolZ", "modulename": "x4i.endl_Z", "qualname": "endl_SymbolZ", "type": "function", "doc": "<p></p>\n", "signature": "(sym)", "funcdef": "def"}, {"fullname": "x4i.endl_Z.endl_ZLabel", "modulename": "x4i.endl_Z", "qualname": "endl_ZLabel", "type": "function", "doc": "<p></p>\n", "signature": "(Z)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing", "modulename": "x4i.exfor_column_parsing", "type": "module", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_column_parsing.absOrNone", "modulename": "x4i.exfor_column_parsing", "qualname": "absOrNone", "type": "function", "doc": "<p></p>\n", "signature": "(x)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.averageColumns", "modulename": "x4i.exfor_column_parsing", "qualname": "averageColumns", "type": "function", "doc": "<p></p>\n", "signature": "(x, y)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.condenseColumn", "modulename": "x4i.exfor_column_parsing", "qualname": "condenseColumn", "type": "function", "doc": "<p></p>\n", "signature": "(x, y)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4ColumnParser", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ColumnParser", "type": "class", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_column_parsing.X4ColumnParser.__init__", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ColumnParser.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    match_labels=None,\n    match_units=None,\n    scale_factor=1.0,\n    off_set=0.0\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4ColumnParser.isMatch", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ColumnParser.isMatch", "type": "function", "doc": "<p></p>\n", "signature": "(self, i, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4ColumnParser.firstMatch", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ColumnParser.firstMatch", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4ColumnParser.allMatches", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ColumnParser.allMatches", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4ColumnParser.getConversion", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ColumnParser.getConversion", "type": "function", "doc": "<p>Looks up the conversion factors to go from quoted units to canonical \"MeV' 'barns' 'no-dim'\n@type units: string\n@param units: non-canonical units string\n@rtype: float\n@return: conversion factor</p>\n", "signature": "(self, units)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4ColumnParser.getColumn", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ColumnParser.getColumn", "type": "function", "doc": "<p></p>\n", "signature": "(self, icol, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4AngleColumnParser", "modulename": "x4i.exfor_column_parsing", "qualname": "X4AngleColumnParser", "type": "class", "doc": "<p></p>\n", "bases": "X4ColumnParser"}, {"fullname": "x4i.exfor_column_parsing.X4AngleColumnParser.getColumn", "modulename": "x4i.exfor_column_parsing", "qualname": "X4AngleColumnParser.getColumn", "type": "function", "doc": "<p></p>\n", "signature": "(self, icol, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4ColumnPairParser", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ColumnPairParser", "type": "class", "doc": "<p>Simple Base class.  Defines init function, but you must override\nthe member functions if you expect anything to work</p>\n"}, {"fullname": "x4i.exfor_column_parsing.X4ColumnPairParser.__init__", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ColumnPairParser.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, column1Parser, column2Parser)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4ColumnPairParser.set_icols", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ColumnPairParser.set_icols", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4ColumnPairParser.isMatch", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ColumnPairParser.isMatch", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4ColumnPairParser.getValue", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ColumnPairParser.getValue", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4ColumnPairParser.getError", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ColumnPairParser.getError", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4ColumnPairParser.getDummyColumn", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ColumnPairParser.getDummyColumn", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4MissingErrorColumnPair", "modulename": "x4i.exfor_column_parsing", "qualname": "X4MissingErrorColumnPair", "type": "class", "doc": "<p>Matches first occurrence of Column 1 (that matches your pointer, if any), ignores Column 2.</p>\n", "bases": "X4ColumnPairParser"}, {"fullname": "x4i.exfor_column_parsing.X4MissingErrorColumnPair.__init__", "modulename": "x4i.exfor_column_parsing", "qualname": "X4MissingErrorColumnPair.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, column1Parser, column2Parser=None)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4MissingErrorColumnPair.set_icols", "modulename": "x4i.exfor_column_parsing", "qualname": "X4MissingErrorColumnPair.set_icols", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4MissingErrorColumnPair.isMatch", "modulename": "x4i.exfor_column_parsing", "qualname": "X4MissingErrorColumnPair.isMatch", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4MissingErrorColumnPair.getValue", "modulename": "x4i.exfor_column_parsing", "qualname": "X4MissingErrorColumnPair.getValue", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4MissingErrorColumnPair.getError", "modulename": "x4i.exfor_column_parsing", "qualname": "X4MissingErrorColumnPair.getError", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4IndependentColumnPair", "modulename": "x4i.exfor_column_parsing", "qualname": "X4IndependentColumnPair", "type": "class", "doc": "<p>Matches first occurrences of Column 1 and 2 (that matches your pointer, if any)</p>\n", "bases": "X4MissingErrorColumnPair"}, {"fullname": "x4i.exfor_column_parsing.X4IndependentColumnPair.set_icols", "modulename": "x4i.exfor_column_parsing", "qualname": "X4IndependentColumnPair.set_icols", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4IndependentColumnPair.isMatch", "modulename": "x4i.exfor_column_parsing", "qualname": "X4IndependentColumnPair.isMatch", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4IndependentColumnPair.getError", "modulename": "x4i.exfor_column_parsing", "qualname": "X4IndependentColumnPair.getError", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4ConstantPercentColumnPair", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ConstantPercentColumnPair", "type": "class", "doc": "<p>Matches first occurance of Column 1, ignores Column 2.\nSet percentError to something other than 10% for real work!</p>\n", "bases": "X4MissingErrorColumnPair"}, {"fullname": "x4i.exfor_column_parsing.X4ConstantPercentColumnPair.__init__", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ConstantPercentColumnPair.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, column1Parser)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4ConstantPercentColumnPair.getError", "modulename": "x4i.exfor_column_parsing", "qualname": "X4ConstantPercentColumnPair.getError", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4HighLowColumnPair", "modulename": "x4i.exfor_column_parsing", "qualname": "X4HighLowColumnPair", "type": "class", "doc": "<p>Matches first occurrences of Column 1 and 2 (that matches your pointer, if any)</p>\n", "bases": "X4IndependentColumnPair"}, {"fullname": "x4i.exfor_column_parsing.X4HighLowColumnPair.isMatch", "modulename": "x4i.exfor_column_parsing", "qualname": "X4HighLowColumnPair.isMatch", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4HighLowColumnPair.getValue", "modulename": "x4i.exfor_column_parsing", "qualname": "X4HighLowColumnPair.getValue", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4HighLowColumnPair.getError", "modulename": "x4i.exfor_column_parsing", "qualname": "X4HighLowColumnPair.getError", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4HighMidLowColumnPair", "modulename": "x4i.exfor_column_parsing", "qualname": "X4HighMidLowColumnPair", "type": "class", "doc": "<p>Matches first occurrences of Column 1 and 2 (that matches your pointer, if any)</p>\n", "bases": "X4IndependentColumnPair"}, {"fullname": "x4i.exfor_column_parsing.X4HighMidLowColumnPair.__init__", "modulename": "x4i.exfor_column_parsing", "qualname": "X4HighMidLowColumnPair.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, column1Parser, column2Parser, column3Parser)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4HighMidLowColumnPair.set_icols", "modulename": "x4i.exfor_column_parsing", "qualname": "X4HighMidLowColumnPair.set_icols", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4HighMidLowColumnPair.isMatch", "modulename": "x4i.exfor_column_parsing", "qualname": "X4HighMidLowColumnPair.isMatch", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4HighMidLowColumnPair.getValue", "modulename": "x4i.exfor_column_parsing", "qualname": "X4HighMidLowColumnPair.getValue", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4HighMidLowColumnPair.getError", "modulename": "x4i.exfor_column_parsing", "qualname": "X4HighMidLowColumnPair.getError", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4AddErrorBarsColumnPair", "modulename": "x4i.exfor_column_parsing", "qualname": "X4AddErrorBarsColumnPair", "type": "class", "doc": "<p>Matches first occurrences of Column 1 and 2 (that matches your pointer, if any)</p>\n", "bases": "X4HighMidLowColumnPair"}, {"fullname": "x4i.exfor_column_parsing.X4AddErrorBarsColumnPair.getValue", "modulename": "x4i.exfor_column_parsing", "qualname": "X4AddErrorBarsColumnPair.getValue", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4AddErrorBarsColumnPair.getError", "modulename": "x4i.exfor_column_parsing", "qualname": "X4AddErrorBarsColumnPair.getError", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4BarnsSqrtEColumnPair", "modulename": "x4i.exfor_column_parsing", "qualname": "X4BarnsSqrtEColumnPair", "type": "class", "doc": "<p>Matches first occurrences of Column 1 and 2 (that matches your pointer, if any)</p>\n", "bases": "X4IndependentColumnPair"}, {"fullname": "x4i.exfor_column_parsing.X4BarnsSqrtEColumnPair.__init__", "modulename": "x4i.exfor_column_parsing", "qualname": "X4BarnsSqrtEColumnPair.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, column2Parser, column3Parser)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4BarnsSqrtEColumnPair.energyColumn", "modulename": "x4i.exfor_column_parsing", "qualname": "X4BarnsSqrtEColumnPair.energyColumn", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4BarnsSqrtEColumnPair.set_icols", "modulename": "x4i.exfor_column_parsing", "qualname": "X4BarnsSqrtEColumnPair.set_icols", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4BarnsSqrtEColumnPair.isMatch", "modulename": "x4i.exfor_column_parsing", "qualname": "X4BarnsSqrtEColumnPair.isMatch", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4BarnsSqrtEColumnPair.getValue", "modulename": "x4i.exfor_column_parsing", "qualname": "X4BarnsSqrtEColumnPair.getValue", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4BarnsSqrtEColumnPair.getError", "modulename": "x4i.exfor_column_parsing", "qualname": "X4BarnsSqrtEColumnPair.getError", "type": "function", "doc": "<p></p>\n", "signature": "(self, data)", "funcdef": "def"}, {"fullname": "x4i.exfor_column_parsing.X4CosineAngleColumnPair", "modulename": "x4i.exfor_column_parsing", "qualname": "X4CosineAngleColumnPair", "type": "class", "doc": "<p>Matches first occurrences of Column 1 and 2 (that matches your pointer, if any)</p>\n", "bases": "X4IndependentColumnPair"}, {"fullname": "x4i.exfor_column_parsing.X4EinCMToLabColumnPair", "modulename": "x4i.exfor_column_parsing", "qualname": "X4EinCMToLabColumnPair", "type": "class", "doc": "<p>Matches first occurrences of Column 1 and 2 (that matches your pointer, if any)</p>\n", "bases": "X4IndependentColumnPair"}, {"fullname": "x4i.exfor_dataset", "modulename": "x4i.exfor_dataset", "type": "module", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_dataset.X4DataSet", "modulename": "x4i.exfor_dataset", "qualname": "X4DataSet", "type": "class", "doc": "<p></p>\n", "bases": "x4i.exfor_section.X4BibMetaData"}, {"fullname": "x4i.exfor_dataset.X4DataSet.__init__", "modulename": "x4i.exfor_dataset", "qualname": "X4DataSet.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    meta=None,\n    common=None,\n    reaction=None,\n    monitor=None,\n    data=None,\n    pointer=None\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4DataSet.setData", "modulename": "x4i.exfor_dataset", "qualname": "X4DataSet.setData", "type": "function", "doc": "<p>This should set up the data, labels and units such that all columns in all COMMON sections are in self\nand such that all columns in DATA which either have no pointer or matching pointer are in self</p>\n", "signature": "(self, data, common=None, pointer=None)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4DataSet.strHeader", "modulename": "x4i.exfor_dataset", "qualname": "X4DataSet.strHeader", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4DataSet.reprHeader", "modulename": "x4i.exfor_dataset", "qualname": "X4DataSet.reprHeader", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4DataSet.sort", "modulename": "x4i.exfor_dataset", "qualname": "X4DataSet.sort", "type": "function", "doc": "<p>In place sort, see Python documentation for list().sort()</p>\n", "signature": "(self, **kw)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4DataSet.getSimplified", "modulename": "x4i.exfor_dataset", "qualname": "X4DataSet.getSimplified", "type": "function", "doc": "<p>Returns a simplified version of self.\ninputs:\n    parserMap            = { 'column name 1':parserList1, 'column name 2':parserList2, ... }\n    columnNames          = [ 'column name 1', 'column name 2', ... ] #put them in the order <em>you</em> want\n    makeAllColumns       will make uncertainty columns even if no uncertainties are given on a particular column\n    failIfMissingErrors  fail (raising exception) if missing an error column</p>\n", "signature": "(\n    self,\n    parserMap=None,\n    columnNames=None,\n    makeAllColumns=False,\n    failIfMissingErrors=False\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4DataSet.append", "modulename": "x4i.exfor_dataset", "qualname": "X4DataSet.append", "type": "function", "doc": "<p></p>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4DataSet.csv", "modulename": "x4i.exfor_dataset", "qualname": "X4DataSet.csv", "type": "function", "doc": "<p></p>\n", "signature": "(self, f)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4DataSet.numcols", "modulename": "x4i.exfor_dataset", "qualname": "X4DataSet.numcols", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4DataSet.numrows", "modulename": "x4i.exfor_dataset", "qualname": "X4DataSet.numrows", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4CrossSectionDataSet", "modulename": "x4i.exfor_dataset", "qualname": "X4CrossSectionDataSet", "type": "class", "doc": "<p></p>\n", "bases": "X4DataSet"}, {"fullname": "x4i.exfor_dataset.X4CrossSectionDataSet.__init__", "modulename": "x4i.exfor_dataset", "qualname": "X4CrossSectionDataSet.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    meta=None,\n    common=None,\n    reaction=None,\n    monitor=None,\n    data=None,\n    pointer=None\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4CrossSectionDataSet.getSimplified", "modulename": "x4i.exfor_dataset", "qualname": "X4CrossSectionDataSet.getSimplified", "type": "function", "doc": "<p>Returns a simplified version of self.\ninputs:\n    parserMap            = { 'column name 1':parserList1, 'column name 2':parserList2, ... }\n    columnNames          = [ 'column name 1', 'column name 2', ... ] #put them in the order <em>you</em> want\n    makeAllColumns       will make uncertainty columns even if no uncertainties are given on a particular column\n    failIfMissingErrors  fail (raising exception) if missing an error column</p>\n", "signature": "(self, makeAllColumns=False, failIfMissingErrors=False)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4NubarDataSet", "modulename": "x4i.exfor_dataset", "qualname": "X4NubarDataSet", "type": "class", "doc": "<p></p>\n", "bases": "X4DataSet"}, {"fullname": "x4i.exfor_dataset.X4NubarDataSet.__init__", "modulename": "x4i.exfor_dataset", "qualname": "X4NubarDataSet.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    meta=None,\n    common=None,\n    reaction=None,\n    monitor=None,\n    data=None,\n    pointer=None\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4NubarDataSet.getSimplified", "modulename": "x4i.exfor_dataset", "qualname": "X4NubarDataSet.getSimplified", "type": "function", "doc": "<p>Returns a simplified version of self.\ninputs:\n    parserMap            = { 'column name 1':parserList1, 'column name 2':parserList2, ... }\n    columnNames          = [ 'column name 1', 'column name 2', ... ] #put them in the order <em>you</em> want\n    makeAllColumns       will make uncertainty columns even if no uncertainties are given on a particular column\n    failIfMissingErrors  fail (raising exception) if missing an error column</p>\n", "signature": "(self, makeAllColumns=False, failIfMissingErrors=False)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4SpectrumAveCrossSectionDataSet", "modulename": "x4i.exfor_dataset", "qualname": "X4SpectrumAveCrossSectionDataSet", "type": "class", "doc": "<p></p>\n", "bases": "X4DataSet"}, {"fullname": "x4i.exfor_dataset.X4SpectrumAveCrossSectionDataSet.__init__", "modulename": "x4i.exfor_dataset", "qualname": "X4SpectrumAveCrossSectionDataSet.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    meta=None,\n    common=None,\n    reaction=None,\n    monitor=None,\n    data=None,\n    pointer=None\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4SpectrumAveCrossSectionDataSet.getSimplified", "modulename": "x4i.exfor_dataset", "qualname": "X4SpectrumAveCrossSectionDataSet.getSimplified", "type": "function", "doc": "<p>Returns a simplified version of self.\ninputs:\n    parserMap            = { 'column name 1':parserList1, 'column name 2':parserList2, ... }\n    columnNames          = [ 'column name 1', 'column name 2', ... ] #put them in the order <em>you</em> want\n    makeAllColumns       will make uncertainty columns even if no uncertainties are given on a particular column\n    failIfMissingErrors  fail (raising exception) if missing an error column</p>\n", "signature": "(self, makeAllColumns=False, failIfMissingErrors=False)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4ResonanceIntCrossSectionDataSet", "modulename": "x4i.exfor_dataset", "qualname": "X4ResonanceIntCrossSectionDataSet", "type": "class", "doc": "<p></p>\n", "bases": "X4DataSet"}, {"fullname": "x4i.exfor_dataset.X4ResonanceIntCrossSectionDataSet.__init__", "modulename": "x4i.exfor_dataset", "qualname": "X4ResonanceIntCrossSectionDataSet.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    meta=None,\n    common=None,\n    reaction=None,\n    monitor=None,\n    data=None,\n    pointer=None\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4ResonanceIntCrossSectionDataSet.getSimplified", "modulename": "x4i.exfor_dataset", "qualname": "X4ResonanceIntCrossSectionDataSet.getSimplified", "type": "function", "doc": "<p>Returns a simplified version of self.\ninputs:\n    parserMap            = { 'column name 1':parserList1, 'column name 2':parserList2, ... }\n    columnNames          = [ 'column name 1', 'column name 2', ... ] #put them in the order <em>you</em> want\n    makeAllColumns       will make uncertainty columns even if no uncertainties are given on a particular column\n    failIfMissingErrors  fail (raising exception) if missing an error column</p>\n", "signature": "(self, makeAllColumns=False, failIfMissingErrors=False)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4AnalyzingPowerDataSet", "modulename": "x4i.exfor_dataset", "qualname": "X4AnalyzingPowerDataSet", "type": "class", "doc": "<p></p>\n", "bases": "X4DataSet"}, {"fullname": "x4i.exfor_dataset.X4AnalyzingPowerDataSet.__init__", "modulename": "x4i.exfor_dataset", "qualname": "X4AnalyzingPowerDataSet.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    meta=None,\n    common=None,\n    reaction=None,\n    monitor=None,\n    data=None,\n    pointer=None\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4AnalyzingPowerDataSet.getSimplified", "modulename": "x4i.exfor_dataset", "qualname": "X4AnalyzingPowerDataSet.getSimplified", "type": "function", "doc": "<p>Returns a simplified version of self.\ninputs:\n    parserMap            = { 'column name 1':parserList1, 'column name 2':parserList2, ... }\n    columnNames          = [ 'column name 1', 'column name 2', ... ] #put them in the order <em>you</em> want\n    makeAllColumns       will make uncertainty columns even if no uncertainties are given on a particular column\n    failIfMissingErrors  fail (raising exception) if missing an error column</p>\n", "signature": "(self, makeAllColumns=False, failIfMissingErrors=False)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4AngularDistributionDataSet", "modulename": "x4i.exfor_dataset", "qualname": "X4AngularDistributionDataSet", "type": "class", "doc": "<p></p>\n", "bases": "X4DataSet"}, {"fullname": "x4i.exfor_dataset.X4AngularDistributionDataSet.__init__", "modulename": "x4i.exfor_dataset", "qualname": "X4AngularDistributionDataSet.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    meta=None,\n    common=None,\n    reaction=None,\n    monitor=None,\n    data=None,\n    pointer=None\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4AngularDistributionDataSet.strHeader", "modulename": "x4i.exfor_dataset", "qualname": "X4AngularDistributionDataSet.strHeader", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4AngularDistributionDataSet.getSimplified", "modulename": "x4i.exfor_dataset", "qualname": "X4AngularDistributionDataSet.getSimplified", "type": "function", "doc": "<p>Returns a simplified version of self.\ninputs:\n    parserMap            = { 'column name 1':parserList1, 'column name 2':parserList2, ... }\n    columnNames          = [ 'column name 1', 'column name 2', ... ] #put them in the order <em>you</em> want\n    makeAllColumns       will make uncertainty columns even if no uncertainties are given on a particular column\n    failIfMissingErrors  fail (raising exception) if missing an error column</p>\n", "signature": "(self, makeAllColumns=False, failIfMissingErrors=False)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4EnergyDistributionDataSet", "modulename": "x4i.exfor_dataset", "qualname": "X4EnergyDistributionDataSet", "type": "class", "doc": "<p></p>\n", "bases": "X4DataSet"}, {"fullname": "x4i.exfor_dataset.X4EnergyDistributionDataSet.__init__", "modulename": "x4i.exfor_dataset", "qualname": "X4EnergyDistributionDataSet.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    meta=None,\n    common=None,\n    reaction=None,\n    monitor=None,\n    data=None,\n    pointer=None\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4EnergyDistributionDataSet.strHeader", "modulename": "x4i.exfor_dataset", "qualname": "X4EnergyDistributionDataSet.strHeader", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4EnergyDistributionDataSet.getSimplified", "modulename": "x4i.exfor_dataset", "qualname": "X4EnergyDistributionDataSet.getSimplified", "type": "function", "doc": "<p>Returns a simplified version of self.\ninputs:\n    parserMap            = { 'column name 1':parserList1, 'column name 2':parserList2, ... }\n    columnNames          = [ 'column name 1', 'column name 2', ... ] #put them in the order <em>you</em> want\n    makeAllColumns       will make uncertainty columns even if no uncertainties are given on a particular column\n    failIfMissingErrors  fail (raising exception) if missing an error column</p>\n", "signature": "(self, makeAllColumns=False, failIfMissingErrors=False)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4EnergyAngleDistDataSet", "modulename": "x4i.exfor_dataset", "qualname": "X4EnergyAngleDistDataSet", "type": "class", "doc": "<p></p>\n", "bases": "X4DataSet"}, {"fullname": "x4i.exfor_dataset.X4EnergyAngleDistDataSet.__init__", "modulename": "x4i.exfor_dataset", "qualname": "X4EnergyAngleDistDataSet.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    meta=None,\n    common=None,\n    reaction=None,\n    monitor=None,\n    data=None,\n    pointer=None\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4EnergyAngleDistDataSet.getSimplified", "modulename": "x4i.exfor_dataset", "qualname": "X4EnergyAngleDistDataSet.getSimplified", "type": "function", "doc": "<p>Returns a simplified version of self.\ninputs:\n    parserMap            = { 'column name 1':parserList1, 'column name 2':parserList2, ... }\n    columnNames          = [ 'column name 1', 'column name 2', ... ] #put them in the order <em>you</em> want\n    makeAllColumns       will make uncertainty columns even if no uncertainties are given on a particular column\n    failIfMissingErrors  fail (raising exception) if missing an error column</p>\n", "signature": "(self, makeAllColumns=False, failIfMissingErrors=False)", "funcdef": "def"}, {"fullname": "x4i.exfor_dataset.X4DataSetFactory", "modulename": "x4i.exfor_dataset", "qualname": "X4DataSetFactory", "type": "function", "doc": "<p></p>\n", "signature": "(\n    quant,\n    meta=None,\n    common=None,\n    reaction=None,\n    monitor=None,\n    data=None,\n    pointer=None\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_dicts", "modulename": "x4i.exfor_dicts", "type": "module", "doc": "<p>exfor_dicts module - Class and Methods for Server that gives look-up tables for abbreviations in EXFOR files</p>\n"}, {"fullname": "x4i.exfor_dicts.getDictionary", "modulename": "x4i.exfor_dicts", "qualname": "getDictionary", "type": "function", "doc": "<p></p>\n", "signature": "(filename, VERBOSELEVEL=0)", "funcdef": "def"}, {"fullname": "x4i.exfor_dicts.X4DictionaryServer", "modulename": "x4i.exfor_dicts", "qualname": "X4DictionaryServer", "type": "class", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_dicts.X4DictionaryServer.__init__", "modulename": "x4i.exfor_dicts", "qualname": "X4DictionaryServer.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    pathToDictionaryFiles='/Users/davidbrown/Desktop/x4i/x4i/dicts/'\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_dicts.X4DictionaryServer.getDictionaryName", "modulename": "x4i.exfor_dicts", "qualname": "X4DictionaryServer.getDictionaryName", "type": "function", "doc": "<p>Look up dictionary name\n@type x: int\n@param x: index of the dictionary\n@rtype: string or None\n@return: name of the dictionary</p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_dicts.X4DictionaryServer.getDictionaryIndex", "modulename": "x4i.exfor_dicts", "qualname": "X4DictionaryServer.getDictionaryIndex", "type": "function", "doc": "<p>Look up index for dictionary named \"x\"\n@type x: string\n@param x: name of the dictionary\n@rtype: int or None\n@return: index of the dictionary</p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_dicts.X4DictionaryServer.getDictionaryFilename", "modulename": "x4i.exfor_dicts", "qualname": "X4DictionaryServer.getDictionaryFilename", "type": "function", "doc": "<p>Figure out file name of requested dictionary\n@type x: string or int\n@param x: name or index of the dictionary\n@rtype: string or None\n@return: filename for the dictionary</p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_dicts.X4DictionaryServer.getDictionary", "modulename": "x4i.exfor_dicts", "qualname": "X4DictionaryServer.getDictionary", "type": "function", "doc": "<p>Retrieve requested dictionary\n@type x: string or int\n@param x: name or index of the dictionary\n@param VERBOSELEVEL: verbosity\n@rtype: matrix\n@return: the dictionary</p>\n", "signature": "(self, x, VERBOSELEVEL=0)", "funcdef": "def"}, {"fullname": "x4i.exfor_dicts.X4DictionaryServer.getAllDictionaries", "modulename": "x4i.exfor_dicts", "qualname": "X4DictionaryServer.getAllDictionaries", "type": "function", "doc": "<p>Retrieve requested dictionary\n@rtype: map or matrices\n@return: map of dictionaries, key is dictionary name</p>\n", "signature": "(self, VERBOSELEVEL=0)", "funcdef": "def"}, {"fullname": "x4i.exfor_entry", "modulename": "x4i.exfor_entry", "type": "module", "doc": "<p>exfor_entry module</p>\n"}, {"fullname": "x4i.exfor_entry.x4EntryFactory", "modulename": "x4i.exfor_entry", "qualname": "x4EntryFactory", "type": "function", "doc": "<p>This function takes an EXFOR ENTRY number (enum), retrieves the corresponding file\nfrom disk, and constructs a valid X4Entry.  The rawEntry=True flag returns optionally\njust the unparsed list of SUBENTs, each as strings.</p>\n", "signature": "(\n    enum,\n    subentsList=None,\n    rawEntry=False,\n    dataPath='/Users/davidbrown/Desktop/x4i/x4i/data'\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_entry.extractX4EntryIndex", "modulename": "x4i.exfor_entry", "qualname": "extractX4EntryIndex", "type": "function", "doc": "<p>Grabs the entry number from the \"ENTRY\" line of an EXFOR entry\n@type  entry: list of strings\n@param entry: list of string containing the Exfor entry\n@rtype: string or None\n@return: the entry index as specified by Exfor</p>\n", "signature": "(entry)", "funcdef": "def"}, {"fullname": "x4i.exfor_entry.X4Entry", "modulename": "x4i.exfor_entry", "qualname": "X4Entry", "type": "class", "doc": "<p>An EXFOR Entry is composed of X4SubEntries</p>\n", "bases": "builtins.dict"}, {"fullname": "x4i.exfor_entry.X4Entry.__init__", "modulename": "x4i.exfor_entry", "qualname": "X4Entry.__init__", "type": "function", "doc": "<p>Expect raw_entry to be a valid list of strings, with each string being one subentry</p>\n", "signature": "(self, raw_entry)", "funcdef": "def"}, {"fullname": "x4i.exfor_entry.X4Entry.chunkify", "modulename": "x4i.exfor_entry", "qualname": "X4Entry.chunkify", "type": "function", "doc": "<p>Takes a list of strings, assumed to be an Exfor Entry and returns a list of SubEntries\n@type  oldentry: list of strings\n@param oldentry: Exfor Entry to be chopped into SubEntries\n@rtype: list of list of strings\n@return: list of list of strings w/ innermost list of strings assumed to be Exfor SubEntries</p>\n", "signature": "(self, oldentry)", "funcdef": "def"}, {"fullname": "x4i.exfor_entry.X4Entry.getDataSets", "modulename": "x4i.exfor_entry", "qualname": "X4Entry.getDataSets", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_entry.X4Entry.getSimplifiedDataSets", "modulename": "x4i.exfor_entry", "qualname": "X4Entry.getSimplifiedDataSets", "type": "function", "doc": "<p></p>\n", "signature": "(self, makeAllColumns=False)", "funcdef": "def"}, {"fullname": "x4i.exfor_entry.X4Entry.sortedKeys", "modulename": "x4i.exfor_entry", "qualname": "X4Entry.sortedKeys", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_entry.X4Entry.deleted", "modulename": "x4i.exfor_entry", "qualname": "X4Entry.deleted", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_entry.X4Entry.meta", "modulename": "x4i.exfor_entry", "qualname": "X4Entry.meta", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_entry.X4EntryMetaData", "modulename": "x4i.exfor_entry", "qualname": "X4EntryMetaData", "type": "class", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_entry.X4EntryMetaData.__init__", "modulename": "x4i.exfor_entry", "qualname": "X4EntryMetaData.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, entry)", "funcdef": "def"}, {"fullname": "x4i.exfor_entry.X4EntryMetaData.xmgraceHeader", "modulename": "x4i.exfor_entry", "qualname": "X4EntryMetaData.xmgraceHeader", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_entry.X4EntryMetaData.citation", "modulename": "x4i.exfor_entry", "qualname": "X4EntryMetaData.citation", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_entry.X4EntryMetaData.legend", "modulename": "x4i.exfor_entry", "qualname": "X4EntryMetaData.legend", "type": "function", "doc": "<p>String suitable for a plot legend</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_exceptions", "modulename": "x4i.exfor_exceptions", "type": "module", "doc": "<p>exfor_exceptions module - Exceptions for Exfor interface</p>\n"}, {"fullname": "x4i.exfor_exceptions.ReferenceParsingError", "modulename": "x4i.exfor_exceptions", "qualname": "ReferenceParsingError", "type": "class", "doc": "<p>Base class for all reference parsing exceptions</p>\n", "bases": "builtins.Exception"}, {"fullname": "x4i.exfor_exceptions.ReferenceParsingError.__init__", "modulename": "x4i.exfor_exceptions", "qualname": "ReferenceParsingError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value='')", "funcdef": "def"}, {"fullname": "x4i.exfor_exceptions.AuthorParsingError", "modulename": "x4i.exfor_exceptions", "qualname": "AuthorParsingError", "type": "class", "doc": "<p>Base class for all author parsing exceptions</p>\n", "bases": "builtins.Exception"}, {"fullname": "x4i.exfor_exceptions.AuthorParsingError.__init__", "modulename": "x4i.exfor_exceptions", "qualname": "AuthorParsingError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value='')", "funcdef": "def"}, {"fullname": "x4i.exfor_exceptions.InstituteParsingError", "modulename": "x4i.exfor_exceptions", "qualname": "InstituteParsingError", "type": "class", "doc": "<p>Base class for all author parsing exceptions</p>\n", "bases": "builtins.Exception"}, {"fullname": "x4i.exfor_exceptions.InstituteParsingError.__init__", "modulename": "x4i.exfor_exceptions", "qualname": "InstituteParsingError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value='')", "funcdef": "def"}, {"fullname": "x4i.exfor_exceptions.ParticleParsingError", "modulename": "x4i.exfor_exceptions", "qualname": "ParticleParsingError", "type": "class", "doc": "<p>Base class for all particle parsing exceptions</p>\n", "bases": "builtins.Exception"}, {"fullname": "x4i.exfor_exceptions.ParticleParsingError.__init__", "modulename": "x4i.exfor_exceptions", "qualname": "ParticleParsingError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value='')", "funcdef": "def"}, {"fullname": "x4i.exfor_exceptions.ReactionParsingError", "modulename": "x4i.exfor_exceptions", "qualname": "ReactionParsingError", "type": "class", "doc": "<p>Base class for all reaction parsing exceptions</p>\n", "bases": "builtins.Exception"}, {"fullname": "x4i.exfor_exceptions.ReactionParsingError.__init__", "modulename": "x4i.exfor_exceptions", "qualname": "ReactionParsingError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value='')", "funcdef": "def"}, {"fullname": "x4i.exfor_exceptions.IsomerMathParsingError", "modulename": "x4i.exfor_exceptions", "qualname": "IsomerMathParsingError", "type": "class", "doc": "<p>Raise this when someone has math expressions in the isomer spot (e.g. 94-Pu-240-M1+M2)</p>\n", "bases": "builtins.Exception"}, {"fullname": "x4i.exfor_exceptions.IsomerMathParsingError.__init__", "modulename": "x4i.exfor_exceptions", "qualname": "IsomerMathParsingError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value='')", "funcdef": "def"}, {"fullname": "x4i.exfor_exceptions.ResidualNucleusError", "modulename": "x4i.exfor_exceptions", "qualname": "ResidualNucleusError", "type": "class", "doc": "<p>Raise this if you can't figure out the residual nucleus</p>\n", "bases": "ReactionParsingError"}, {"fullname": "x4i.exfor_exceptions.ResidualNucleusError.__init__", "modulename": "x4i.exfor_exceptions", "qualname": "ResidualNucleusError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value='')", "funcdef": "def"}, {"fullname": "x4i.exfor_exceptions.DataSectionParsingError", "modulename": "x4i.exfor_exceptions", "qualname": "DataSectionParsingError", "type": "class", "doc": "<p>Base class for all data parsing exceptions</p>\n", "bases": "builtins.Exception"}, {"fullname": "x4i.exfor_exceptions.DataSectionParsingError.__init__", "modulename": "x4i.exfor_exceptions", "qualname": "DataSectionParsingError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value='')", "funcdef": "def"}, {"fullname": "x4i.exfor_exceptions.BrokenNumberError", "modulename": "x4i.exfor_exceptions", "qualname": "BrokenNumberError", "type": "class", "doc": "<p>Raise this when you get a badly formatted number</p>\n", "bases": "DataSectionParsingError"}, {"fullname": "x4i.exfor_exceptions.BrokenNumberError.__init__", "modulename": "x4i.exfor_exceptions", "qualname": "BrokenNumberError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value='')", "funcdef": "def"}, {"fullname": "x4i.exfor_exceptions.BadUnitsError", "modulename": "x4i.exfor_exceptions", "qualname": "BadUnitsError", "type": "class", "doc": "<p>Raise this when you get units no one can use</p>\n", "bases": "DataSectionParsingError"}, {"fullname": "x4i.exfor_exceptions.BadUnitsError.__init__", "modulename": "x4i.exfor_exceptions", "qualname": "BadUnitsError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value='')", "funcdef": "def"}, {"fullname": "x4i.exfor_exceptions.UserInterventionRequired", "modulename": "x4i.exfor_exceptions", "qualname": "UserInterventionRequired", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n", "bases": "builtins.Exception"}, {"fullname": "x4i.exfor_exceptions.UserInterventionRequired.__init__", "modulename": "x4i.exfor_exceptions", "qualname": "UserInterventionRequired.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value='')", "funcdef": "def"}, {"fullname": "x4i.exfor_exceptions.NoUncertaintyGivenError", "modulename": "x4i.exfor_exceptions", "qualname": "NoUncertaintyGivenError", "type": "class", "doc": "<p>Base class for all data parsing exceptions</p>\n", "bases": "DataSectionParsingError"}, {"fullname": "x4i.exfor_exceptions.NoUncertaintyGivenError.__init__", "modulename": "x4i.exfor_exceptions", "qualname": "NoUncertaintyGivenError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value='')", "funcdef": "def"}, {"fullname": "x4i.exfor_exceptions.NoHopeForUncertaintyError", "modulename": "x4i.exfor_exceptions", "qualname": "NoHopeForUncertaintyError", "type": "class", "doc": "<p>Base class for all data parsing exceptions</p>\n", "bases": "DataSectionParsingError"}, {"fullname": "x4i.exfor_exceptions.NoHopeForUncertaintyError.__init__", "modulename": "x4i.exfor_exceptions", "qualname": "NoHopeForUncertaintyError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value='')", "funcdef": "def"}, {"fullname": "x4i.exfor_exceptions.NoValuesGivenError", "modulename": "x4i.exfor_exceptions", "qualname": "NoValuesGivenError", "type": "class", "doc": "<p>Base class for all data parsing exceptions</p>\n", "bases": "DataSectionParsingError"}, {"fullname": "x4i.exfor_exceptions.NoValuesGivenError.__init__", "modulename": "x4i.exfor_exceptions", "qualname": "NoValuesGivenError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, value='')", "funcdef": "def"}, {"fullname": "x4i.exfor_field", "modulename": "x4i.exfor_field", "type": "module", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_field.chunkifyX4TextField", "modulename": "x4i.exfor_field", "qualname": "chunkifyX4TextField", "type": "function", "doc": "<p>Splits an EXFOR text field into chunks, code pieces ( i.e. \"(blah, blah)\" ) get there own chunks and \"free text\"\nget their own chunks.  Works best on 'INSTITUTE' field.  Would be better to move to pyparsing based scheme.\n@type  oldtext: string\n@param oldtext: raw line from an EXFOR file\n@rtype: list of strings\n@return: list containing the (hopefully) parsed Exfor text field</p>\n", "signature": "(oldtext)", "funcdef": "def"}, {"fullname": "x4i.exfor_field.extractX4FieldType", "modulename": "x4i.exfor_field", "qualname": "extractX4FieldType", "type": "function", "doc": "<p>Extracts the type of field from an EXFOR field.  It should be in cols[0:10] of the field string.\n@type  field: string\n@param field: string containing the EXFOR field\n@rtype: string or None\n@return: the name of the field</p>\n", "signature": "(field)", "funcdef": "def"}, {"fullname": "x4i.exfor_field.extractX4FieldPointer", "modulename": "x4i.exfor_field", "qualname": "extractX4FieldPointer", "type": "function", "doc": "<p>Extracts a pointer (if it exists) from an EXFOR field.  It should be in column 10 of the field string.\n@type  field: string\n@param field: string containing the EXFOR field\n@rtype: string or None\n@return: the pointer or None if there is none</p>\n", "signature": "(field)", "funcdef": "def"}, {"fullname": "x4i.exfor_field.X4SubField", "modulename": "x4i.exfor_field", "qualname": "X4SubField", "type": "class", "doc": "<p>smallest element of an EXFOR text field; may span several lines</p>\n", "bases": "builtins.list"}, {"fullname": "x4i.exfor_field.X4PlainField", "modulename": "x4i.exfor_field", "qualname": "X4PlainField", "type": "class", "doc": "<p>EXFOR plain data field in a Bib Section, with extra character grabbed from tag field to catch possible pointers</p>\n", "bases": "builtins.dict"}, {"fullname": "x4i.exfor_field.X4PlainField.total_len", "modulename": "x4i.exfor_field", "qualname": "X4PlainField.total_len", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_field.X4ReactionField", "modulename": "x4i.exfor_field", "qualname": "X4ReactionField", "type": "class", "doc": "<p>Parsed EXFOR Reaction Field</p>\n", "bases": "X4PlainField"}, {"fullname": "x4i.exfor_field.X4ReactionField.getMeasurementType", "modulename": "x4i.exfor_field", "qualname": "X4ReactionField.getMeasurementType", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_field.X4ReactionField.getEquation", "modulename": "x4i.exfor_field", "qualname": "X4ReactionField.getEquation", "type": "function", "doc": "<p>Produced a list of strings corresponding to the parsed reaction field.</p>\n\n<p>Arguments ::</p>\n\n<pre><code>* key : the EXFOR pointer (either '' or an integer)\n* schematic : If True, will return the equation with the strings \"rxn 0\", 'rxn 1' etc.\n    where the reactions used to be.  This is good for computer algebra.  If False,\n    the repr() of the X4Reaction instance.\n</code></pre>\n", "signature": "(self, key, schematic=False)", "funcdef": "def"}, {"fullname": "x4i.exfor_field.X4ReactionField.getX4ReactionList", "modulename": "x4i.exfor_field", "qualname": "X4ReactionField.getX4ReactionList", "type": "function", "doc": "<p>Produce a list of X4Reaction instances that are present in a reaction string.  For a\nsimple reaction, this is a one element list with the X4Reaction instance in it.  For a\nreaction combination, this is a list of X4Reaction instances, entered in order of\noccurrence in the reaction string.  The list can be used to fill in the schematic output from\ngetEquation() to produce the non-schematic version.</p>\n\n<p>Arguments:</p>\n\n<pre><code>* key : the EXFOR pointer (either '' or an integer)\n</code></pre>\n", "signature": "(self, key)", "funcdef": "def"}, {"fullname": "x4i.exfor_field.X4MonitorField", "modulename": "x4i.exfor_field", "qualname": "X4MonitorField", "type": "class", "doc": "<p>Parsed Exfor Monitor Field</p>\n\n<p>The reaction monitors are stored in the <code>reactions</code> data member, just like an regular X4ReactionField.\nThis is a Python dict who's keys are a reaction pointer (' ' if there isn't one) and\nvalue are a list of all monitors for this reaction.  The elements of the list of\nmonitors are a 3-tuple: ( X4Reaction, free text, DATA column reference ) ::</p>\n\n<pre><code>- The X4Reaction, is the monitor reaction\n- The free text is free text entered by the EXFOR compiler\n- The DATA column reference is the column header of the monitor reaction data\n  given in the DATA section of this EXFOR subentry.\n</code></pre>\n", "bases": "X4ReactionField"}, {"fullname": "x4i.exfor_field.X4ReferenceField", "modulename": "x4i.exfor_field", "qualname": "X4ReferenceField", "type": "class", "doc": "<p>Parsed EXFOR reference field</p>\n", "bases": "X4PlainField"}, {"fullname": "x4i.exfor_field.X4ReferenceField.flatten", "modulename": "x4i.exfor_field", "qualname": "X4ReferenceField.flatten", "type": "function", "doc": "<p>flattens nested parens in volume part of a reference</p>\n", "signature": "(self, l)", "funcdef": "def"}, {"fullname": "x4i.exfor_field.X4TitleField", "modulename": "x4i.exfor_field", "qualname": "X4TitleField", "type": "class", "doc": "<p>Cleaned up title</p>\n", "bases": "X4PlainField"}, {"fullname": "x4i.exfor_field.X4AuthorField", "modulename": "x4i.exfor_field", "qualname": "X4AuthorField", "type": "class", "doc": "<p>Cleaned up author list</p>\n", "bases": "X4PlainField"}, {"fullname": "x4i.exfor_field.X4InstituteField", "modulename": "x4i.exfor_field", "qualname": "X4InstituteField", "type": "class", "doc": "<p>Cleaned up institutes list</p>\n", "bases": "X4PlainField"}, {"fullname": "x4i.exfor_grammars", "modulename": "x4i.exfor_grammars", "type": "module", "doc": "<p>exfor_grammars module - Collection of pyparsing grammars for parsing Exfor objects</p>\n"}, {"fullname": "x4i.exfor_manager", "modulename": "x4i.exfor_manager", "type": "module", "doc": "<p>exfor_manager module - Classes and Methods to retrieve EXFOR Entries and SubEntries from the database</p>\n"}, {"fullname": "x4i.exfor_manager.decompress_entry", "modulename": "x4i.exfor_manager", "qualname": "decompress_entry", "type": "function", "doc": "<p>Some databases zip the (Sub)Entries before storing them.  This routine unzips them.</p>\n", "signature": "(s)", "funcdef": "def"}, {"fullname": "x4i.exfor_manager.X4DBManager", "modulename": "x4i.exfor_manager", "qualname": "X4DBManager", "type": "class", "doc": "<p>EXFOR data base manager base class\nThis defines the API.</p>\n\n<p>As a user, you should use __init__ to establish the connection to your preferred database,\nthen access data using the query, retrieve, __getitem__ and __contains__ member functions.</p>\n\n<p>All of the other member functions should only be needed by code developers.</p>\n"}, {"fullname": "x4i.exfor_manager.X4DBManager.__init__", "modulename": "x4i.exfor_manager", "qualname": "X4DBManager.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kw)", "funcdef": "def"}, {"fullname": "x4i.exfor_manager.X4DBManager.run_sql_query", "modulename": "x4i.exfor_manager", "qualname": "X4DBManager.run_sql_query", "type": "function", "doc": "<p>Performs the actual SQL query, returns the number of results so you can request that\nmany by calling CURSOR.fetchmany()</p>\n", "signature": "(self, table, column, condition=None, VERBOSE=False)", "funcdef": "def"}, {"fullname": "x4i.exfor_manager.X4DBManager.query", "modulename": "x4i.exfor_manager", "qualname": "X4DBManager.query", "type": "function", "doc": "<p>Use this function to search for all (Sub)Entries matching criteria in query call.\nThis function returns a dictionary with the following structure:\n    { ENTRY#0:[ SUBENT001, SUBENT#1, SUBENT#2, ... ], ... }.\nHere ENTRY#0 is the entry number whose subentries match the query.  The SUBENT001 is the documentation\nsubentry number, which is always included, and SUBENT#1, ... are the subentry numbers matching the search\ncriteria.</p>\n", "signature": "(\n    self,\n    author=None,\n    reaction=None,\n    target=None,\n    projectile=None,\n    quantity=None,\n    product=None,\n    MF=None,\n    MT=None,\n    C=None,\n    S=None,\n    I=None,\n    SUBENT=None,\n    ENTRY=None\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_manager.X4DBManager.retrieve", "modulename": "x4i.exfor_manager", "qualname": "X4DBManager.retrieve", "type": "function", "doc": "<p>Execute a query, matching the criteria specified.\nThis function returns a dictionary with the following structure:\n    { ENTRY#0:[ SUBENT001, SUBENT#1, SUBENT#2, ... ], ... }.\nHere ENTRY#0 is the entry number whose subentries match the query.  The SUBENT001 is the documentation subentry\nitself, which is always included, and SUBENT#1, ... are the subentries themselves matching the search\ncriteria.</p>\n", "signature": "(\n    self,\n    author=None,\n    reaction=None,\n    target=None,\n    projectile=None,\n    quantity=None,\n    product=None,\n    MF=None,\n    MT=None,\n    C=None,\n    S=None,\n    I=None,\n    SUBENT=None,\n    ENTRY=None\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_manager.X4DBManagerPlainFS", "modulename": "x4i.exfor_manager", "qualname": "X4DBManagerPlainFS", "type": "class", "doc": "<p>EXFOR data base manager for data stored on local filesystem in directory hierarchy.</p>\n", "bases": "X4DBManager"}, {"fullname": "x4i.exfor_manager.X4DBManagerPlainFS.__init__", "modulename": "x4i.exfor_manager", "qualname": "X4DBManagerPlainFS.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kw)", "funcdef": "def"}, {"fullname": "x4i.exfor_manager.X4DBManagerPlainFS.query", "modulename": "x4i.exfor_manager", "qualname": "X4DBManagerPlainFS.query", "type": "function", "doc": "<p>Use this function to search for all (Sub)Entries matching criteria in query call.\nThis function returns a dictionary with the following structure:\n    { ENTRY#0:[ SUBENT001, SUBENT#1, SUBENT#2, ... ], ... }.\nHere ENTRY#0 is the entry number whose subentries match the query.  The SUBENT001 is the documentation subentry\nnumber, which is always included, and SUBENT#1, ... are the subentry numbers matching the search criteria.</p>\n", "signature": "(\n    self,\n    author=None,\n    reaction=None,\n    target=None,\n    projectile=None,\n    quantity=None,\n    product=None,\n    MF=None,\n    MT=None,\n    C=None,\n    S=None,\n    I=None,\n    SUBENT=None,\n    ENTRY=None,\n    reference=None\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_manager.X4DBManagerPlainFS.retrieve", "modulename": "x4i.exfor_manager", "qualname": "X4DBManagerPlainFS.retrieve", "type": "function", "doc": "<p>Execute a query, matching the criteria specified.\nThis function returns a dictionary with the following structure:\n    { ENTRY#0:[ SUBENT001, SUBENT#1, SUBENT#2, ... ], ... }.\nHere ENTRY#0 is the entry number whose subentries match the query.  The SUBENT001 is the documentation subentry\nitself, which is always included, and SUBENT#1, ... are the subentries themselves matching the search criteria.</p>\n\n<p>If the flag rawEntry is True, the raw text versions of the SUBENTs will be returned, otherwise they will be\nconverted to X4Entry instances.</p>\n", "signature": "(\n    self,\n    author=None,\n    reaction=None,\n    target=None,\n    projectile=None,\n    quantity=None,\n    product=None,\n    MF=None,\n    MT=None,\n    C=None,\n    S=None,\n    I=None,\n    SUBENT=None,\n    ENTRY=None,\n    rawEntry=False,\n    reference=None,\n    as_JSON=False\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_manager.X4DBManagerDefault", "modulename": "x4i.exfor_manager", "qualname": "X4DBManagerDefault", "type": "class", "doc": "<p>EXFOR data base manager for data stored on local filesystem in directory hierarchy.</p>\n", "bases": "X4DBManager"}, {"fullname": "x4i.exfor_manager.X4DBManagerDefault.__init__", "modulename": "x4i.exfor_manager", "qualname": "X4DBManagerDefault.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kw)", "funcdef": "def"}, {"fullname": "x4i.exfor_manager.X4DBManagerDefault.query", "modulename": "x4i.exfor_manager", "qualname": "X4DBManagerDefault.query", "type": "function", "doc": "<p>Use this function to search for all (Sub)Entries matching criteria in query call.\nThis function returns a dictionary with the following structure:\n    { ENTRY#0:[ SUBENT001, SUBENT#1, SUBENT#2, ... ], ... }.\nHere ENTRY#0 is the entry number whose subentries match the query.  The SUBENT001 is the documentation subentry\nnumber, which is always included, and SUBENT#1, ... are the subentry numbers matching the search criteria.</p>\n", "signature": "(\n    self,\n    author=None,\n    reaction=None,\n    target=None,\n    projectile=None,\n    quantity=None,\n    product=None,\n    MF=None,\n    MT=None,\n    C=None,\n    S=None,\n    I=None,\n    SUBENT=None,\n    ENTRY=None,\n    reference=None\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_manager.X4DBManagerDefault.retrieve", "modulename": "x4i.exfor_manager", "qualname": "X4DBManagerDefault.retrieve", "type": "function", "doc": "<p>Execute a query, matching the criteria specified.\nThis function returns a dictionary with the following structure:\n    { ENTRY#0:[ SUBENT001, SUBENT#1, SUBENT#2, ... ], ... }.\nHere ENTRY#0 is the entry number whose subentries match the query.  The SUBENT001 is the documentation subentry\nitself, which is always included, and SUBENT#1, ... are the subentries themselves matching the search criteria.</p>\n\n<p>If the flag rawEntry is True, the raw text versions of the SUBENTs will be returned, otherwise they will be\nconverted to X4Entry instances.</p>\n", "signature": "(\n    self,\n    author=None,\n    reaction=None,\n    target=None,\n    projectile=None,\n    quantity=None,\n    product=None,\n    MF=None,\n    MT=None,\n    C=None,\n    S=None,\n    I=None,\n    SUBENT=None,\n    ENTRY=None,\n    rawEntry=False,\n    reference=None,\n    as_JSON=False\n)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle", "modulename": "x4i.exfor_particle", "type": "module", "doc": "<p>parse_exfor_particle. module - Classes and Methods to process Exfor Particle and Nucleus strings</p>\n"}, {"fullname": "x4i.exfor_particle.X4ParticleBase", "modulename": "x4i.exfor_particle", "qualname": "X4ParticleBase", "type": "class", "doc": "<p>Base class for all particle types</p>\n"}, {"fullname": "x4i.exfor_particle.X4ParticleBase.__init__", "modulename": "x4i.exfor_particle", "qualname": "X4ParticleBase.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ParticleBase.parse", "modulename": "x4i.exfor_particle", "qualname": "X4ParticleBase.parse", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ParticleBase.getZ", "modulename": "x4i.exfor_particle", "qualname": "X4ParticleBase.getZ", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ParticleBase.getA", "modulename": "x4i.exfor_particle", "qualname": "X4ParticleBase.getA", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ParticleBase.asList", "modulename": "x4i.exfor_particle", "qualname": "X4ParticleBase.asList", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ParticleBase.endlZAStyle", "modulename": "x4i.exfor_particle", "qualname": "X4ParticleBase.endlZAStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ParticleBase.exforStyle", "modulename": "x4i.exfor_particle", "qualname": "X4ParticleBase.exforStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ParticleBase.gndStyle", "modulename": "x4i.exfor_particle", "qualname": "X4ParticleBase.gndStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ParticleBase.gndsStyle", "modulename": "x4i.exfor_particle", "qualname": "X4ParticleBase.gndsStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ParticleBase.prettyStyle", "modulename": "x4i.exfor_particle", "qualname": "X4ParticleBase.prettyStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Particle", "modulename": "x4i.exfor_particle", "qualname": "X4Particle", "type": "class", "doc": "<p>Parsed particle string (can actually be several real particles)</p>\n", "bases": "X4ParticleBase"}, {"fullname": "x4i.exfor_particle.X4Particle.__init__", "modulename": "x4i.exfor_particle", "qualname": "X4Particle.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Particle.parse", "modulename": "x4i.exfor_particle", "qualname": "X4Particle.parse", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Particle.prettyStyle", "modulename": "x4i.exfor_particle", "qualname": "X4Particle.prettyStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Particle.exforStyle", "modulename": "x4i.exfor_particle", "qualname": "X4Particle.exforStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Nucleus", "modulename": "x4i.exfor_particle", "qualname": "X4Nucleus", "type": "class", "doc": "<p>Parsed EXFOR nucleus</p>\n", "bases": "X4ParticleBase"}, {"fullname": "x4i.exfor_particle.X4Nucleus.__init__", "modulename": "x4i.exfor_particle", "qualname": "X4Nucleus.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Nucleus.parse", "modulename": "x4i.exfor_particle", "qualname": "X4Nucleus.parse", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Nucleus.endlZAStyle", "modulename": "x4i.exfor_particle", "qualname": "X4Nucleus.endlZAStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Nucleus.exforStyle", "modulename": "x4i.exfor_particle", "qualname": "X4Nucleus.exforStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Nucleus.gndStyle", "modulename": "x4i.exfor_particle", "qualname": "X4Nucleus.gndStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Nucleus.gndsStyle", "modulename": "x4i.exfor_particle", "qualname": "X4Nucleus.gndsStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Nucleus.prettyStyle", "modulename": "x4i.exfor_particle", "qualname": "X4Nucleus.prettyStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Isomer", "modulename": "x4i.exfor_particle", "qualname": "X4Isomer", "type": "class", "doc": "<p>Parsed Exfor nucleus with list of isomers</p>\n", "bases": "X4Nucleus"}, {"fullname": "x4i.exfor_particle.X4Isomer.__init__", "modulename": "x4i.exfor_particle", "qualname": "X4Isomer.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, x, IgnoreIsomerMath=False)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Isomer.endlZAStyle", "modulename": "x4i.exfor_particle", "qualname": "X4Isomer.endlZAStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Isomer.exforStyle", "modulename": "x4i.exfor_particle", "qualname": "X4Isomer.exforStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Isomer.gndStyle", "modulename": "x4i.exfor_particle", "qualname": "X4Isomer.gndStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Isomer.gndsStyle", "modulename": "x4i.exfor_particle", "qualname": "X4Isomer.gndsStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Isomer.prettyStyle", "modulename": "x4i.exfor_particle", "qualname": "X4Isomer.prettyStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Element", "modulename": "x4i.exfor_particle", "qualname": "X4Element", "type": "class", "doc": "<p>Parsed EXFOR nucleus with nonsense A because is really a natural element</p>\n", "bases": "X4Nucleus"}, {"fullname": "x4i.exfor_particle.X4Element.getA", "modulename": "x4i.exfor_particle", "qualname": "X4Element.getA", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Element.prettyStyle", "modulename": "x4i.exfor_particle", "qualname": "X4Element.prettyStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4Element.gndsStyle", "modulename": "x4i.exfor_particle", "qualname": "X4Element.gndsStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4VariableParticle", "modulename": "x4i.exfor_particle", "qualname": "X4VariableParticle", "type": "class", "doc": "<p>Particle with nonsense Z &amp; A when the Z &amp; A are possibly or actually variable</p>\n", "bases": "X4Particle"}, {"fullname": "x4i.exfor_particle.X4VariableParticle.__init__", "modulename": "x4i.exfor_particle", "qualname": "X4VariableParticle.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4VariableParticle.getZ", "modulename": "x4i.exfor_particle", "qualname": "X4VariableParticle.getZ", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4VariableParticle.getA", "modulename": "x4i.exfor_particle", "qualname": "X4VariableParticle.getA", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ChemicalCompound", "modulename": "x4i.exfor_particle", "qualname": "X4ChemicalCompound", "type": "class", "doc": "<p>Chemical compound, essentially a variable particle with complicated symbol</p>\n", "bases": "X4ParticleBase"}, {"fullname": "x4i.exfor_particle.X4ChemicalCompound.__init__", "modulename": "x4i.exfor_particle", "qualname": "X4ChemicalCompound.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ChemicalCompound.parse", "modulename": "x4i.exfor_particle", "qualname": "X4ChemicalCompound.parse", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ChemicalCompound.getA", "modulename": "x4i.exfor_particle", "qualname": "X4ChemicalCompound.getA", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ChemicalCompound.asList", "modulename": "x4i.exfor_particle", "qualname": "X4ChemicalCompound.asList", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ChemicalCompound.endlZAStyle", "modulename": "x4i.exfor_particle", "qualname": "X4ChemicalCompound.endlZAStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ChemicalCompound.exforStyle", "modulename": "x4i.exfor_particle", "qualname": "X4ChemicalCompound.exforStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_particle.X4ChemicalCompound.prettyStyle", "modulename": "x4i.exfor_particle", "qualname": "X4ChemicalCompound.prettyStyle", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions", "modulename": "x4i.exfor_reactions", "type": "module", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_reactions.X4Process", "modulename": "x4i.exfor_reactions", "qualname": "X4Process", "type": "class", "doc": "<p>Parsed Exfor process, namely just the \"target+projectile -> stuff\" part of a string</p>\n"}, {"fullname": "x4i.exfor_reactions.X4Process.__init__", "modulename": "x4i.exfor_reactions", "qualname": "X4Process.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, xl, IgnoreIsomerMath=False)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4Process.parse", "modulename": "x4i.exfor_reactions", "qualname": "X4Process.parse", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4Process.setParticleType", "modulename": "x4i.exfor_reactions", "qualname": "X4Process.setParticleType", "type": "function", "doc": "<p>Figures out what a particle i corresponds to, then creates it</p>\n", "signature": "(self, i)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4Process.setProduct", "modulename": "x4i.exfor_reactions", "qualname": "X4Process.setProduct", "type": "function", "doc": "<p>Figures out what the product of a reaction is, whether it is one or more particles or whether it\nis a catch-all (e.g. Nonelastic)</p>\n", "signature": "(self, i)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4Process.setResidual", "modulename": "x4i.exfor_reactions", "qualname": "X4Process.setResidual", "type": "function", "doc": "<p>Figures out if it is possible for this process to uniquely give a residual and if so, what it is</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4Process.setProcessType", "modulename": "x4i.exfor_reactions", "qualname": "X4Process.setProcessType", "type": "function", "doc": "<p>Figures out what the process type is from the products list</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4Measurement", "modulename": "x4i.exfor_reactions", "qualname": "X4Measurement", "type": "class", "doc": "<p>Parsed EXFOR measurement.  This is a dummy class to organize the reaction or reaction combo classes</p>\n"}, {"fullname": "x4i.exfor_reactions.X4Measurement.__init__", "modulename": "x4i.exfor_reactions", "qualname": "X4Measurement.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, pointer, comment)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4Reaction", "modulename": "x4i.exfor_reactions", "qualname": "X4Reaction", "type": "class", "doc": "<p>Parsed EXFOR reaction.  This is a process, plus all the modifiers that follow it (e.g. \"SIG\" or \"NU\")</p>\n", "bases": "X4Process, X4Measurement"}, {"fullname": "x4i.exfor_reactions.X4Reaction.__init__", "modulename": "x4i.exfor_reactions", "qualname": "X4Reaction.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, x, IgnoreIsomerMath=False)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4Reaction.parse", "modulename": "x4i.exfor_reactions", "qualname": "X4Reaction.parse", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4Reaction.has_quantity", "modulename": "x4i.exfor_reactions", "qualname": "X4Reaction.has_quantity", "type": "function", "doc": "<p></p>\n", "signature": "(self, i)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4Reaction.getReactionType", "modulename": "x4i.exfor_reactions", "qualname": "X4Reaction.getReactionType", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4ReactionCombination", "modulename": "x4i.exfor_reactions", "qualname": "X4ReactionCombination", "type": "class", "doc": "<p>Parsed Exfor reaction combination.  This is what is measured when</p>\n", "bases": "X4Measurement"}, {"fullname": "x4i.exfor_reactions.X4ReactionCombination.__init__", "modulename": "x4i.exfor_reactions", "qualname": "X4ReactionCombination.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4ReactionCombination.parse", "modulename": "x4i.exfor_reactions", "qualname": "X4ReactionCombination.parse", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4ReactionCombination.getStrOrX4Reaction", "modulename": "x4i.exfor_reactions", "qualname": "X4ReactionCombination.getStrOrX4Reaction", "type": "function", "doc": "<p></p>\n", "signature": "(self, i)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4ReactionCombination.getReactionList", "modulename": "x4i.exfor_reactions", "qualname": "X4ReactionCombination.getReactionList", "type": "function", "doc": "<p>assemble a list of all the reactions in self.data</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4ReactionCombination.has_quantity", "modulename": "x4i.exfor_reactions", "qualname": "X4ReactionCombination.has_quantity", "type": "function", "doc": "<p></p>\n", "signature": "(self, i)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4ReactionCombination.print_gizmo", "modulename": "x4i.exfor_reactions", "qualname": "X4ReactionCombination.print_gizmo", "type": "function", "doc": "<p></p>\n", "signature": "(self, op)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4ReactionIsomerCombination", "modulename": "x4i.exfor_reactions", "qualname": "X4ReactionIsomerCombination", "type": "class", "doc": "<p>Parsed Exfor reaction combination.  This is what is measured when</p>\n", "bases": "X4ReactionCombination"}, {"fullname": "x4i.exfor_reactions.X4ReactionIsomerCombination.__init__", "modulename": "x4i.exfor_reactions", "qualname": "X4ReactionIsomerCombination.__init__", "type": "function", "doc": "<p>Repack x to unravel the isomer math, then delegate to the X4ReactionCombination constructor</p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_reactions.X4ReactionIsomerCombination.repack", "modulename": "x4i.exfor_reactions", "qualname": "X4ReactionIsomerCombination.repack", "type": "function", "doc": "<p>Repacks an instance of isomer math as a reaction combination.  It does this by ::</p>\n\n<pre><code>- disassembling the list of parts of the reaction\n- disassemble the residual coding to pull apart the isomer math from the isomers themselves\n- reassemble the reactions as the list you'd get if this was a reaction combination\n</code></pre>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_reference", "modulename": "x4i.exfor_reference", "type": "module", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_reference.parseX4Year", "modulename": "x4i.exfor_reference", "qualname": "parseX4Year", "type": "function", "doc": "<p>Parses year string in the 50 or so variations in the Exfor data\n@type  date: string\n@param date: String containing the potential date\n@rtype:      string\n@return:     4-digit representation of the year</p>\n", "signature": "(date)", "funcdef": "def"}, {"fullname": "x4i.exfor_reference.X4ReferenceCode", "modulename": "x4i.exfor_reference", "qualname": "X4ReferenceCode", "type": "class", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_reference.X4ReferenceCode.__init__", "modulename": "x4i.exfor_reference", "qualname": "X4ReferenceCode.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, x)", "funcdef": "def"}, {"fullname": "x4i.exfor_reference.X4ReferenceCode.getRefName", "modulename": "x4i.exfor_reference", "qualname": "X4ReferenceCode.getRefName", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_section", "modulename": "x4i.exfor_section", "type": "module", "doc": "<p>exfor_sections module -</p>\n"}, {"fullname": "x4i.exfor_section.X4Section", "modulename": "x4i.exfor_section", "qualname": "X4Section", "type": "class", "doc": "<p>Base class inserted just to make structure clear.  Stuff in the section remain unparsed.</p>\n"}, {"fullname": "x4i.exfor_section.X4Section.__init__", "modulename": "x4i.exfor_section", "qualname": "X4Section.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, tag='', unprocessed_section=None)", "funcdef": "def"}, {"fullname": "x4i.exfor_section.chunkify", "modulename": "x4i.exfor_section", "qualname": "chunkify", "type": "function", "doc": "<p>Takes a list of strings, assumed to be an EXFOR 'BIB' section and splits the section into chunks\n@type  oldsection: list of strings\n@param oldsection: Section to be chopped into chunks\n@rtype: list of list of strings\n@return: list of list of strings w/ inner list of strings assumed to be Exfor fields</p>\n", "signature": "(oldsection)", "funcdef": "def"}, {"fullname": "x4i.exfor_section.X4BibSection", "modulename": "x4i.exfor_section", "qualname": "X4BibSection", "type": "class", "doc": "<p>Exfor Bib Section, composed of X4PlainFields</p>\n", "bases": "X4Section, builtins.dict"}, {"fullname": "x4i.exfor_section.X4BibSection.totalLen", "modulename": "x4i.exfor_section", "qualname": "X4BibSection.totalLen", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_section.X4BibSection.meta", "modulename": "x4i.exfor_section", "qualname": "X4BibSection.meta", "type": "function", "doc": "<p></p>\n", "signature": "(self, subent)", "funcdef": "def"}, {"fullname": "x4i.exfor_section.X4BibMetaData", "modulename": "x4i.exfor_section", "qualname": "X4BibMetaData", "type": "class", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4BibMetaData.__init__", "modulename": "x4i.exfor_section", "qualname": "X4BibMetaData.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kw)", "funcdef": "def"}, {"fullname": "x4i.exfor_section.X4BibMetaData.subent", "modulename": "x4i.exfor_section", "qualname": "X4BibMetaData.subent", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4BibMetaData.xmgraceHeader", "modulename": "x4i.exfor_section", "qualname": "X4BibMetaData.xmgraceHeader", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_section.X4BibMetaData.citation", "modulename": "x4i.exfor_section", "qualname": "X4BibMetaData.citation", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_section.X4BibMetaData.legend", "modulename": "x4i.exfor_section", "qualname": "X4BibMetaData.legend", "type": "function", "doc": "<p>String suitable for a plot legend</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_section.X4BibMetaData.author", "modulename": "x4i.exfor_section", "qualname": "X4BibMetaData.author", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4BibMetaData.institute", "modulename": "x4i.exfor_section", "qualname": "X4BibMetaData.institute", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4BibMetaData.pubType", "modulename": "x4i.exfor_section", "qualname": "X4BibMetaData.pubType", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4BibMetaData.reference", "modulename": "x4i.exfor_section", "qualname": "X4BibMetaData.reference", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4BibMetaData.title", "modulename": "x4i.exfor_section", "qualname": "X4BibMetaData.title", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4BibMetaData.year", "modulename": "x4i.exfor_section", "qualname": "X4BibMetaData.year", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4DataSection", "modulename": "x4i.exfor_section", "qualname": "X4DataSection", "type": "class", "doc": "<p>Exfor Data Section</p>\n", "bases": "X4Section"}, {"fullname": "x4i.exfor_section.X4DataSection.__init__", "modulename": "x4i.exfor_section", "qualname": "X4DataSection.__init__", "type": "function", "doc": "<p>Data members of this class ::</p>\n\n<pre><code>- numcols: The number of columns in the data block\n- numrows: The number of logical (or real?) rows in the data block\n- VERBOSELEVEL: Verbosity level flag, probably unused\n- LPR: The number lines in a DATA block per row of real data\n- labels: A Python list of the column labels of the data in each column.\n- units: A Python list of the units of the data in each column.\n- pointers: A Python dict of {pointer:column}\n- raw_data: A Python list of lists containing the data itself as strings\n- data: A Python list of lists containing the data itself, after deFORTRANization\n</code></pre>\n", "signature": "(self, tag, unprocessed_section=None)", "funcdef": "def"}, {"fullname": "x4i.exfor_section.X4DataSection.numcols", "modulename": "x4i.exfor_section", "qualname": "X4DataSection.numcols", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4DataSection.numrows", "modulename": "x4i.exfor_section", "qualname": "X4DataSection.numrows", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4DataSection.VERBOSELEVEL", "modulename": "x4i.exfor_section", "qualname": "X4DataSection.VERBOSELEVEL", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4DataSection.LPR", "modulename": "x4i.exfor_section", "qualname": "X4DataSection.LPR", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4DataSection.labels", "modulename": "x4i.exfor_section", "qualname": "X4DataSection.labels", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4DataSection.units", "modulename": "x4i.exfor_section", "qualname": "X4DataSection.units", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4DataSection.pointers", "modulename": "x4i.exfor_section", "qualname": "X4DataSection.pointers", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4DataSection.raw_data", "modulename": "x4i.exfor_section", "qualname": "X4DataSection.raw_data", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4DataSection.data", "modulename": "x4i.exfor_section", "qualname": "X4DataSection.data", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "x4i.exfor_section.X4DataSection.csv", "modulename": "x4i.exfor_section", "qualname": "X4DataSection.csv", "type": "function", "doc": "<p></p>\n", "signature": "(self, f)", "funcdef": "def"}, {"fullname": "x4i.exfor_section.X4DataSection.as_dict", "modulename": "x4i.exfor_section", "qualname": "X4DataSection.as_dict", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.exfor_subentry", "modulename": "x4i.exfor_subentry", "type": "module", "doc": "<p>exfor_subentry module -</p>\n"}, {"fullname": "x4i.exfor_subentry.extractX4SubEntryIndex", "modulename": "x4i.exfor_subentry", "qualname": "extractX4SubEntryIndex", "type": "function", "doc": "<p>Grabs the subentry number from the \"SUBENT\" line of an EXFOR subentry\n@type  subentry: list of strings\n@param subentry: list of string containing the EXFOR subentry\n@rtype:  string or None\n@return: the subentry index as specified by EXFOR</p>\n", "signature": "(subentry)", "funcdef": "def"}, {"fullname": "x4i.exfor_subentry.extractX4SectionType", "modulename": "x4i.exfor_subentry", "qualname": "extractX4SectionType", "type": "function", "doc": "<p>Extracts the type of EXFOR section from the token in cols[0:10] from the first line that has non-white space there\n@type  section: list of strings\n@param section: list of strings to look to find a valid tag\n@rtype: string or None\n@return: string containing the section type.  Is one of 'BIB', 'DATA' or 'COMMON'</p>\n", "signature": "(section)", "funcdef": "def"}, {"fullname": "x4i.exfor_subentry.X4SubEntry", "modulename": "x4i.exfor_subentry", "qualname": "X4SubEntry", "type": "class", "doc": "<p>Exfor SubEntry, composed of X4Sections (X4BibSections and X4DataSections)</p>\n", "bases": "builtins.dict"}, {"fullname": "x4i.exfor_subentry.X4SubEntry.chunkify", "modulename": "x4i.exfor_subentry", "qualname": "X4SubEntry.chunkify", "type": "function", "doc": "<p>Takes a list of strings, assumed to be an EXFOR subentry and returns a list of subsections\n@type  oldsubentry: list of strings\n@param oldsubentry: EXFOR SubEntry to be chopped into subsections\n@rtype: list of list of strings\n@return: list of list of strings w/ innermost list of strings assumed to be Exfor subsections</p>\n", "signature": "(self, oldsubentry)", "funcdef": "def"}, {"fullname": "x4i.exfor_utilities", "modulename": "x4i.exfor_utilities", "type": "module", "doc": "<p>exfor_utils module - Classes, Methods and Utility functions to aid in parsing Exfor formatted data</p>\n"}, {"fullname": "x4i.exfor_utilities.bigBanner", "modulename": "x4i.exfor_utilities", "qualname": "bigBanner", "type": "function", "doc": "<p>Big banner, with flowerbox</p>\n", "signature": "(x)", "funcdef": "def"}, {"fullname": "x4i.exfor_utilities.smallBanner", "modulename": "x4i.exfor_utilities", "qualname": "smallBanner", "type": "function", "doc": "<p>Small banner, with wings</p>\n", "signature": "(x, wingsize=10)", "funcdef": "def"}, {"fullname": "x4i.exfor_utilities.formatExceptionInfo", "modulename": "x4i.exfor_utilities", "qualname": "formatExceptionInfo", "type": "function", "doc": "<p></p>\n", "signature": "(maxTBlevel=5)", "funcdef": "def"}, {"fullname": "x4i.exfor_utilities.timeit", "modulename": "x4i.exfor_utilities", "qualname": "timeit", "type": "function", "doc": "<p>A timing decorator.  Use it like this:</p>\n\n<pre><code>&gt;&gt;&gt; @timeit\n&gt;&gt;&gt; def f1():\n&gt;&gt;&gt;    time.sleep(1)\n&gt;&gt;&gt;    print('f1')\n</code></pre>\n", "signature": "(method)", "funcdef": "def"}, {"fullname": "x4i.exfor_utilities.withinXPercent", "modulename": "x4i.exfor_utilities", "qualname": "withinXPercent", "type": "function", "doc": "<p></p>\n", "signature": "(a, b, percent=1.0, absTol=1e-14)", "funcdef": "def"}, {"fullname": "x4i.exfor_utilities.allWithinXPercent", "modulename": "x4i.exfor_utilities", "qualname": "allWithinXPercent", "type": "function", "doc": "<p></p>\n", "signature": "(aL, bL, percent=1.0, absTol=1e-14)", "funcdef": "def"}, {"fullname": "x4i.exfor_utilities.unique", "modulename": "x4i.exfor_utilities", "qualname": "unique", "type": "function", "doc": "<p></p>\n", "signature": "(l)", "funcdef": "def"}, {"fullname": "x4i.exfor_utilities.parseFORTRANNumber", "modulename": "x4i.exfor_utilities", "qualname": "parseFORTRANNumber", "type": "function", "doc": "<p>Parses a number string in the 50 or so variations seen in the Exfor data\n@type  numstring: string\n@param numstring: String containing the potential number\n@rtype:      number\n@return:     the hopefully correctly parsed number</p>\n", "signature": "(numstring)", "funcdef": "def"}, {"fullname": "x4i.exfor_utilities.chunkifyX4Request", "modulename": "x4i.exfor_utilities", "qualname": "chunkifyX4Request", "type": "function", "doc": "<p>Gizmo to break a raw Exfor request (in the form of a list of strings) into a list of EXFOR entries\n(themselves just lists of strings)</p>\n\n<p>@type  request: list of strings\n@param request: Exfor Request to be chopped into Exfor Entries\n@rtype: list of list of strings\n@return: list of list of strings w/ innermost list of strings assumed to be Exfor Entries</p>\n", "signature": "(request)", "funcdef": "def"}, {"fullname": "x4i.exfor_utilities.list_of_dicts_to_table", "modulename": "x4i.exfor_utilities", "qualname": "list_of_dicts_to_table", "type": "function", "doc": "<p></p>\n", "signature": "(list_of_dicts, cols=None)", "funcdef": "def"}, {"fullname": "x4i.exfor_utilities.latex_format_table", "modulename": "x4i.exfor_utilities", "qualname": "latex_format_table", "type": "function", "doc": "<p></p>\n", "signature": "(cols, table)", "funcdef": "def"}, {"fullname": "x4i.exfor_utilities.prettyprint_table", "modulename": "x4i.exfor_utilities", "qualname": "prettyprint_table", "type": "function", "doc": "<p></p>\n", "signature": "(colLabels, table, colwidth=20)", "funcdef": "def"}, {"fullname": "x4i.exfor_utilities.open_for_reading_universal_newline_flag", "modulename": "x4i.exfor_utilities", "qualname": "open_for_reading_universal_newline_flag", "type": "function", "doc": "<p></p>\n", "signature": "(f, newline=None)", "funcdef": "def"}, {"fullname": "x4i.pyparsing", "modulename": "x4i.pyparsing", "type": "module", "doc": "<h1 id=\"pyparsing-module-classes-and-methods-to-define-and-execute-parsing-grammars\">pyparsing module - Classes and methods to define and execute parsing grammars</h1>\n\n<p>The pyparsing module is an alternative approach to creating and\nexecuting simple grammars, vs. the traditional lex/yacc approach, or the\nuse of regular expressions.  With pyparsing, you don't need to learn\na new syntax for defining grammars or matching expressions - the parsing\nmodule provides a library of classes that you use to construct the\ngrammar directly in Python.</p>\n\n<p>Here is a program to parse \"Hello, World!\" (or any greeting of the form\n<code>\"&lt;salutation&gt;, &lt;addressee&gt;!\"</code>), built up using <code>Word</code>,\n<code>Literal</code>, and <code>And</code> elements\n(the <code>'+'&lt;ParserElement.__add__&gt;</code> operators create <code>And</code> expressions,\nand the strings are auto-converted to <code>Literal</code> expressions)::</p>\n\n<pre><code>from pyparsing import Word, alphas\n\n# define grammar of a greeting\ngreet = Word(alphas) + \",\" + Word(alphas) + \"!\"\n\nhello = \"Hello, World!\"\nprint (hello, \"-&gt;\", greet.parseString(hello))\n</code></pre>\n\n<p>The program outputs the following::</p>\n\n<pre><code>Hello, World! -&gt; ['Hello', ',', 'World', '!']\n</code></pre>\n\n<p>The Python representation of the grammar is quite readable, owing to the\nself-explanatory class names, and the use of '+', '|' and '^' operators.</p>\n\n<p>The <code>ParseResults</code> object returned from\n<code>ParserElement.parseString</code> can be\naccessed as a nested list, a dictionary, or an object with named\nattributes.</p>\n\n<p>The pyparsing module handles some of the problems that are typically\nvexing when writing text parsers:</p>\n\n<ul>\n<li>extra or missing whitespace (the above program will also handle\n\"Hello,World!\", \"Hello  ,  World  !\", etc.)</li>\n<li>quoted strings</li>\n<li>embedded comments</li>\n</ul>\n\n<h2 id=\"getting-started-\">Getting Started -</h2>\n\n<p>Visit the classes <code>ParserElement</code> and <code>ParseResults</code> to\nsee the base classes that most other pyparsing\nclasses inherit from. Use the docstrings for examples of how to:</p>\n\n<ul>\n<li>construct literal match expressions from <code>Literal</code> and\n<code>CaselessLiteral</code> classes</li>\n<li>construct character word-group expressions using the <code>Word</code>\nclass</li>\n<li>see how to create repetitive expressions using <code>ZeroOrMore</code>\nand <code>OneOrMore</code> classes</li>\n<li>use <code>'+'&lt;And&gt;</code>, <code>'|'&lt;MatchFirst&gt;</code>, <code>'^'&lt;Or&gt;</code>,\nand <code>'&amp;'&lt;Each&gt;</code> operators to combine simple expressions into\nmore complex ones</li>\n<li>associate names with your parsed results using\n<code>ParserElement.setResultsName</code></li>\n<li>find some helpful expression short-cuts like <code>delimitedList</code>\nand <code>oneOf</code></li>\n<li>find more useful common expressions in the <code>pyparsing_common</code>\nnamespace class</li>\n</ul>\n"}, {"fullname": "x4i.pyparsing.And", "modulename": "x4i.pyparsing", "qualname": "And", "type": "class", "doc": "<p>Requires all given <code>ParseExpression</code> s to be found in the given order.\nExpressions may be separated by whitespace.\nMay be constructed using the <code>'+'</code> operator.\nMay also be constructed using the <code>'-'</code> operator, which will\nsuppress backtracking.</p>\n\n<p>Example::</p>\n\n<pre><code>integer = Word(nums)\nname_expr = OneOrMore(Word(alphas))\n\nexpr = And([integer(\"id\"),name_expr(\"name\"),integer(\"age\")])\n# more easily written as:\nexpr = integer(\"id\") + name_expr(\"name\") + integer(\"age\")\n</code></pre>\n", "bases": "ParseExpression"}, {"fullname": "x4i.pyparsing.And.__init__", "modulename": "x4i.pyparsing", "qualname": "And.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, exprs, savelist=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.And.parseImpl", "modulename": "x4i.pyparsing", "qualname": "And.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.And.checkRecursion", "modulename": "x4i.pyparsing", "qualname": "And.checkRecursion", "type": "function", "doc": "<p></p>\n", "signature": "(self, parseElementList)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.CaselessKeyword", "modulename": "x4i.pyparsing", "qualname": "CaselessKeyword", "type": "class", "doc": "<p>Caseless version of <code>Keyword</code>.</p>\n\n<p>Example::</p>\n\n<pre><code>OneOrMore(CaselessKeyword(\"CMD\")).parseString(\"cmd CMD Cmd10\") # -&gt; ['CMD', 'CMD']\n</code></pre>\n\n<p>(Contrast with example for <code>CaselessLiteral</code>.)</p>\n", "bases": "Keyword"}, {"fullname": "x4i.pyparsing.CaselessKeyword.__init__", "modulename": "x4i.pyparsing", "qualname": "CaselessKeyword.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, matchString, identChars=None)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.CaselessKeyword.parseImpl", "modulename": "x4i.pyparsing", "qualname": "CaselessKeyword.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.CaselessLiteral", "modulename": "x4i.pyparsing", "qualname": "CaselessLiteral", "type": "class", "doc": "<p>Token to match a specified string, ignoring case of letters.\nNote: the matched results will always be in the case of the given\nmatch string, NOT the case of the input text.</p>\n\n<p>Example::</p>\n\n<pre><code>OneOrMore(CaselessLiteral(\"CMD\")).parseString(\"cmd CMD Cmd10\") # -&gt; ['CMD', 'CMD', 'CMD']\n</code></pre>\n\n<p>(Contrast with example for <code>CaselessKeyword</code>.)</p>\n", "bases": "Literal"}, {"fullname": "x4i.pyparsing.CaselessLiteral.__init__", "modulename": "x4i.pyparsing", "qualname": "CaselessLiteral.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, matchString)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.CaselessLiteral.parseImpl", "modulename": "x4i.pyparsing", "qualname": "CaselessLiteral.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.CharsNotIn", "modulename": "x4i.pyparsing", "qualname": "CharsNotIn", "type": "class", "doc": "<p>Token for matching words composed of characters <em>not</em> in a given\nset (will include whitespace in matched characters if not listed in\nthe provided exclusion set - see example). Defined with string\ncontaining all disallowed characters, and an optional minimum,\nmaximum, and/or exact length.  The default value for <code>min</code> is\n1 (a minimum value &lt; 1 is not valid); the default values for\n<code>max</code> and <code>exact</code> are 0, meaning no maximum or exact\nlength restriction.</p>\n\n<p>Example::</p>\n\n<pre><code># define a comma-separated-value as anything that is not a ','\ncsv_value = CharsNotIn(',')\nprint(delimitedList(csv_value).parseString(\"dkls,lsdkjf,s12 34,@!#,213\"))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>['dkls', 'lsdkjf', 's12 34', '@!#', '213']\n</code></pre>\n", "bases": "Token"}, {"fullname": "x4i.pyparsing.CharsNotIn.__init__", "modulename": "x4i.pyparsing", "qualname": "CharsNotIn.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, notChars, min=1, max=0, exact=0)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.CharsNotIn.parseImpl", "modulename": "x4i.pyparsing", "qualname": "CharsNotIn.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Combine", "modulename": "x4i.pyparsing", "qualname": "Combine", "type": "class", "doc": "<p>Converter to concatenate all matching tokens to a single string.\nBy default, the matching patterns must also be contiguous in the\ninput string; this can be disabled by specifying\n<code>'adjacent=False'</code> in the constructor.</p>\n\n<p>Example::</p>\n\n<pre><code>real = Word(nums) + '.' + Word(nums)\nprint(real.parseString('3.1416')) # -&gt; ['3', '.', '1416']\n# will also erroneously match the following\nprint(real.parseString('3. 1416')) # -&gt; ['3', '.', '1416']\n\nreal = Combine(Word(nums) + '.' + Word(nums))\nprint(real.parseString('3.1416')) # -&gt; ['3.1416']\n# no match when there are internal spaces\nprint(real.parseString('3. 1416')) # -&gt; Exception: Expected W:(0123...)\n</code></pre>\n", "bases": "TokenConverter"}, {"fullname": "x4i.pyparsing.Combine.__init__", "modulename": "x4i.pyparsing", "qualname": "Combine.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, expr, joinString='', adjacent=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Combine.ignore", "modulename": "x4i.pyparsing", "qualname": "Combine.ignore", "type": "function", "doc": "<p>Define expression to be ignored (e.g., comments) while doing pattern\nmatching; may be called repeatedly, to define multiple comment or other\nignorable patterns.</p>\n\n<p>Example::</p>\n\n<pre><code>patt = OneOrMore(Word(alphas))\npatt.parseString('ablaj /* comment */ lskjd') # -&gt; ['ablaj']\n\npatt.ignore(cStyleComment)\npatt.parseString('ablaj /* comment */ lskjd') # -&gt; ['ablaj', 'lskjd']\n</code></pre>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Combine.postParse", "modulename": "x4i.pyparsing", "qualname": "Combine.postParse", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, tokenlist)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Dict", "modulename": "x4i.pyparsing", "qualname": "Dict", "type": "class", "doc": "<p>Converter to return a repetitive expression as a list, but also\nas a dictionary. Each element can also be referenced using the first\ntoken in the expression as its key. Useful for tabular report\nscraping when the first column can be used as a item key.</p>\n\n<p>Example::</p>\n\n<pre><code>data_word = Word(alphas)\nlabel = data_word + FollowedBy(':')\nattr_expr = Group(label + Suppress(':') + OneOrMore(data_word).setParseAction(' '.join))\n\ntext = \"shape: SQUARE posn: upper left color: light blue texture: burlap\"\nattr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))\n\n# print attributes as plain groups\nprint(OneOrMore(attr_expr).parseString(text).dump())\n\n# instead of OneOrMore(expr), parse using Dict(OneOrMore(Group(expr))) - Dict will auto-assign names\nresult = Dict(OneOrMore(Group(attr_expr))).parseString(text)\nprint(result.dump())\n\n# access named fields as dict entries, or output as dict\nprint(result['shape'])\nprint(result.asDict())\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>['shape', 'SQUARE', 'posn', 'upper left', 'color', 'light blue', 'texture', 'burlap']\n[['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]\n- color: light blue\n- posn: upper left\n- shape: SQUARE\n- texture: burlap\nSQUARE\n{'color': 'light blue', 'posn': 'upper left', 'texture': 'burlap', 'shape': 'SQUARE'}\n</code></pre>\n\n<p>See more examples at <code>ParseResults</code> of accessing fields by results name.</p>\n", "bases": "TokenConverter"}, {"fullname": "x4i.pyparsing.Dict.__init__", "modulename": "x4i.pyparsing", "qualname": "Dict.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, expr)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Dict.postParse", "modulename": "x4i.pyparsing", "qualname": "Dict.postParse", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, tokenlist)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Each", "modulename": "x4i.pyparsing", "qualname": "Each", "type": "class", "doc": "<p>Requires all given <code>ParseExpression</code> s to be found, but in\nany order. Expressions may be separated by whitespace.</p>\n\n<p>May be constructed using the <code>'&amp;'</code> operator.</p>\n\n<p>Example::</p>\n\n<pre><code>color = oneOf(\"RED ORANGE YELLOW GREEN BLUE PURPLE BLACK WHITE BROWN\")\nshape_type = oneOf(\"SQUARE CIRCLE TRIANGLE STAR HEXAGON OCTAGON\")\ninteger = Word(nums)\nshape_attr = \"shape:\" + shape_type(\"shape\")\nposn_attr = \"posn:\" + Group(integer(\"x\") + ',' + integer(\"y\"))(\"posn\")\ncolor_attr = \"color:\" + color(\"color\")\nsize_attr = \"size:\" + integer(\"size\")\n\n# use Each (using operator '&amp;') to accept attributes in any order\n# (shape and posn are required, color and size are optional)\nshape_spec = shape_attr &amp; posn_attr &amp; Optional(color_attr) &amp; Optional(size_attr)\n\nshape_spec.runTests('''\n    shape: SQUARE color: BLACK posn: 100, 120\n    shape: CIRCLE size: 50 color: BLUE posn: 50,80\n    color:GREEN size:20 shape:TRIANGLE posn:20,40\n    '''\n    )\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>shape: SQUARE color: BLACK posn: 100, 120\n['shape:', 'SQUARE', 'color:', 'BLACK', 'posn:', ['100', ',', '120']]\n- color: BLACK\n- posn: ['100', ',', '120']\n  - x: 100\n  - y: 120\n- shape: SQUARE\n\n\nshape: CIRCLE size: 50 color: BLUE posn: 50,80\n['shape:', 'CIRCLE', 'size:', '50', 'color:', 'BLUE', 'posn:', ['50', ',', '80']]\n- color: BLUE\n- posn: ['50', ',', '80']\n  - x: 50\n  - y: 80\n- shape: CIRCLE\n- size: 50\n\n\ncolor: GREEN size: 20 shape: TRIANGLE posn: 20,40\n['color:', 'GREEN', 'size:', '20', 'shape:', 'TRIANGLE', 'posn:', ['20', ',', '40']]\n- color: GREEN\n- posn: ['20', ',', '40']\n  - x: 20\n  - y: 40\n- shape: TRIANGLE\n- size: 20\n</code></pre>\n", "bases": "ParseExpression"}, {"fullname": "x4i.pyparsing.Each.__init__", "modulename": "x4i.pyparsing", "qualname": "Each.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, exprs, savelist=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Each.parseImpl", "modulename": "x4i.pyparsing", "qualname": "Each.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Each.checkRecursion", "modulename": "x4i.pyparsing", "qualname": "Each.checkRecursion", "type": "function", "doc": "<p></p>\n", "signature": "(self, parseElementList)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Empty", "modulename": "x4i.pyparsing", "qualname": "Empty", "type": "class", "doc": "<p>An empty token, will always match.</p>\n", "bases": "Token"}, {"fullname": "x4i.pyparsing.Empty.__init__", "modulename": "x4i.pyparsing", "qualname": "Empty.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.FollowedBy", "modulename": "x4i.pyparsing", "qualname": "FollowedBy", "type": "class", "doc": "<p>Lookahead matching of the given parse expression.\n<code>FollowedBy</code> does <em>not</em> advance the parsing position within\nthe input string, it only verifies that the specified parse\nexpression matches at the current position.  <code>FollowedBy</code>\nalways returns a null token list. If any results names are defined\nin the lookahead expression, those <em>will</em> be returned for access by\nname.</p>\n\n<p>Example::</p>\n\n<pre><code># use FollowedBy to match a label only if it is followed by a ':'\ndata_word = Word(alphas)\nlabel = data_word + FollowedBy(':')\nattr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))\n\nOneOrMore(attr_expr).parseString(\"shape: SQUARE color: BLACK posn: upper left\").pprint()\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>[['shape', 'SQUARE'], ['color', 'BLACK'], ['posn', 'upper left']]\n</code></pre>\n", "bases": "ParseElementEnhance"}, {"fullname": "x4i.pyparsing.FollowedBy.__init__", "modulename": "x4i.pyparsing", "qualname": "FollowedBy.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, expr)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.FollowedBy.parseImpl", "modulename": "x4i.pyparsing", "qualname": "FollowedBy.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Forward", "modulename": "x4i.pyparsing", "qualname": "Forward", "type": "class", "doc": "<p>Forward declaration of an expression to be defined later -\nused for recursive grammars, such as algebraic infix notation.\nWhen the expression is known, it is assigned to the <code>Forward</code>\nvariable using the '&lt;&lt;' operator.</p>\n\n<p>Note: take care when assigning to <code>Forward</code> not to overlook\nprecedence of operators.</p>\n\n<p>Specifically, '|' has a lower precedence than '&lt;&lt;', so that::</p>\n\n<pre><code>fwdExpr &lt;&lt; a | b | c\n</code></pre>\n\n<p>will actually be evaluated as::</p>\n\n<pre><code>(fwdExpr &lt;&lt; a) | b | c\n</code></pre>\n\n<p>thereby leaving b and c out as parseable alternatives.  It is recommended that you\nexplicitly group the values inserted into the <code>Forward</code>::</p>\n\n<pre><code>fwdExpr &lt;&lt; (a | b | c)\n</code></pre>\n\n<p>Converting to use the '&lt;&lt;=' operator instead will avoid this problem.</p>\n\n<p>See <code>ParseResults.pprint</code> for an example of a recursive\nparser created using <code>Forward</code>.</p>\n", "bases": "ParseElementEnhance"}, {"fullname": "x4i.pyparsing.Forward.__init__", "modulename": "x4i.pyparsing", "qualname": "Forward.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, other=None)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Forward.leaveWhitespace", "modulename": "x4i.pyparsing", "qualname": "Forward.leaveWhitespace", "type": "function", "doc": "<p>Disables the skipping of whitespace before matching the characters in the\n<code>ParserElement</code>'s defined pattern.  This is normally only used internally by\nthe pyparsing module, but may be needed in some whitespace-sensitive grammars.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Forward.streamline", "modulename": "x4i.pyparsing", "qualname": "Forward.streamline", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Forward.validate", "modulename": "x4i.pyparsing", "qualname": "Forward.validate", "type": "function", "doc": "<p>Check defined expressions for valid structure, check for infinite recursive definitions.</p>\n", "signature": "(self, validateTrace=[])", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Forward.copy", "modulename": "x4i.pyparsing", "qualname": "Forward.copy", "type": "function", "doc": "<p>Make a copy of this <code>ParserElement</code>.  Useful for defining\ndifferent parse actions for the same parsing pattern, using copies of\nthe original parse element.</p>\n\n<p>Example::</p>\n\n<pre><code>integer = Word(nums).setParseAction(lambda toks: int(toks[0]))\nintegerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress(\"K\")\nintegerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress(\"M\")\n\nprint(OneOrMore(integerK | integerM | integer).parseString(\"5K 100 640K 256M\"))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>[5120, 100, 655360, 268435456]\n</code></pre>\n\n<p>Equivalent form of <code>expr.copy()</code> is just <code>expr()</code>::</p>\n\n<pre><code>integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress(\"M\")\n</code></pre>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.GoToColumn", "modulename": "x4i.pyparsing", "qualname": "GoToColumn", "type": "class", "doc": "<p>Token to advance to a specific column of input text; useful for\ntabular report scraping.</p>\n", "bases": "_PositionToken"}, {"fullname": "x4i.pyparsing.GoToColumn.__init__", "modulename": "x4i.pyparsing", "qualname": "GoToColumn.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, colno)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.GoToColumn.preParse", "modulename": "x4i.pyparsing", "qualname": "GoToColumn.preParse", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.GoToColumn.parseImpl", "modulename": "x4i.pyparsing", "qualname": "GoToColumn.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Group", "modulename": "x4i.pyparsing", "qualname": "Group", "type": "class", "doc": "<p>Converter to return the matched tokens as a list - useful for\nreturning tokens of <code>ZeroOrMore</code> and <code>OneOrMore</code> expressions.</p>\n\n<p>Example::</p>\n\n<pre><code>ident = Word(alphas)\nnum = Word(nums)\nterm = ident | num\nfunc = ident + Optional(delimitedList(term))\nprint(func.parseString(\"fn a,b,100\"))  # -&gt; ['fn', 'a', 'b', '100']\n\nfunc = ident + Group(Optional(delimitedList(term)))\nprint(func.parseString(\"fn a,b,100\"))  # -&gt; ['fn', ['a', 'b', '100']]\n</code></pre>\n", "bases": "TokenConverter"}, {"fullname": "x4i.pyparsing.Group.__init__", "modulename": "x4i.pyparsing", "qualname": "Group.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, expr)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Group.postParse", "modulename": "x4i.pyparsing", "qualname": "Group.postParse", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, tokenlist)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Keyword", "modulename": "x4i.pyparsing", "qualname": "Keyword", "type": "class", "doc": "<p>Token to exactly match a specified string as a keyword, that is,\nit must be immediately followed by a non-keyword character.  Compare\nwith <code>Literal</code>:</p>\n\n<ul>\n<li><code>Literal(\"if\")</code> will match the leading <code>'if'</code> in\n<code>'ifAndOnlyIf'</code>.</li>\n<li><code>Keyword(\"if\")</code> will not; it will only match the leading\n<code>'if'</code> in <code>'if x=1'</code>, or <code>'if(y==2)'</code></li>\n</ul>\n\n<p>Accepts two optional constructor arguments in addition to the\nkeyword string:</p>\n\n<ul>\n<li><code>identChars</code> is a string of characters that would be valid\nidentifier characters, defaulting to all alphanumerics + \"_\" and\n\"$\"</li>\n<li><code>caseless</code> allows case-insensitive matching, default is <code>False</code>.</li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code>Keyword(\"start\").parseString(\"start\")  # -&gt; ['start']\nKeyword(\"start\").parseString(\"starting\")  # -&gt; Exception\n</code></pre>\n\n<p>For case-insensitive matching, use <code>CaselessKeyword</code>.</p>\n", "bases": "Token"}, {"fullname": "x4i.pyparsing.Keyword.__init__", "modulename": "x4i.pyparsing", "qualname": "Keyword.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, matchString, identChars=None, caseless=False)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Keyword.DEFAULT_KEYWORD_CHARS", "modulename": "x4i.pyparsing", "qualname": "Keyword.DEFAULT_KEYWORD_CHARS", "type": "variable", "doc": "<p></p>\n", "default_value": " = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$'"}, {"fullname": "x4i.pyparsing.Keyword.parseImpl", "modulename": "x4i.pyparsing", "qualname": "Keyword.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Keyword.copy", "modulename": "x4i.pyparsing", "qualname": "Keyword.copy", "type": "function", "doc": "<p>Make a copy of this <code>ParserElement</code>.  Useful for defining\ndifferent parse actions for the same parsing pattern, using copies of\nthe original parse element.</p>\n\n<p>Example::</p>\n\n<pre><code>integer = Word(nums).setParseAction(lambda toks: int(toks[0]))\nintegerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress(\"K\")\nintegerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress(\"M\")\n\nprint(OneOrMore(integerK | integerM | integer).parseString(\"5K 100 640K 256M\"))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>[5120, 100, 655360, 268435456]\n</code></pre>\n\n<p>Equivalent form of <code>expr.copy()</code> is just <code>expr()</code>::</p>\n\n<pre><code>integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress(\"M\")\n</code></pre>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Keyword.setDefaultKeywordChars", "modulename": "x4i.pyparsing", "qualname": "Keyword.setDefaultKeywordChars", "type": "function", "doc": "<p>Overrides the default Keyword chars</p>\n", "signature": "(chars)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.LineEnd", "modulename": "x4i.pyparsing", "qualname": "LineEnd", "type": "class", "doc": "<p>Matches if current position is at the end of a line within the\nparse string</p>\n", "bases": "_PositionToken"}, {"fullname": "x4i.pyparsing.LineEnd.__init__", "modulename": "x4i.pyparsing", "qualname": "LineEnd.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.LineEnd.parseImpl", "modulename": "x4i.pyparsing", "qualname": "LineEnd.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.LineStart", "modulename": "x4i.pyparsing", "qualname": "LineStart", "type": "class", "doc": "<p>Matches if current position is at the beginning of a line within\nthe parse string</p>\n\n<p>Example::</p>\n\n<pre><code>test = '''        AAA this line\nAAA and this line\n  AAA but not this one\nB AAA and definitely not this one\n'''\n\nfor t in (LineStart() + 'AAA' + restOfLine).searchString(test):\n    print(t)\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>['AAA', ' this line']\n['AAA', ' and this line']\n</code></pre>\n", "bases": "_PositionToken"}, {"fullname": "x4i.pyparsing.LineStart.__init__", "modulename": "x4i.pyparsing", "qualname": "LineStart.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.LineStart.parseImpl", "modulename": "x4i.pyparsing", "qualname": "LineStart.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Literal", "modulename": "x4i.pyparsing", "qualname": "Literal", "type": "class", "doc": "<p>Token to exactly match a specified string.</p>\n\n<p>Example::</p>\n\n<pre><code>Literal('blah').parseString('blah')  # -&gt; ['blah']\nLiteral('blah').parseString('blahfooblah')  # -&gt; ['blah']\nLiteral('blah').parseString('bla')  # -&gt; Exception: Expected \"blah\"\n</code></pre>\n\n<p>For case-insensitive matching, use <code>CaselessLiteral</code>.</p>\n\n<p>For keyword matching (force word break before and after the matched string),\nuse <code>Keyword</code> or <code>CaselessKeyword</code>.</p>\n", "bases": "Token"}, {"fullname": "x4i.pyparsing.Literal.__init__", "modulename": "x4i.pyparsing", "qualname": "Literal.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, matchString)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Literal.parseImpl", "modulename": "x4i.pyparsing", "qualname": "Literal.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.PrecededBy", "modulename": "x4i.pyparsing", "qualname": "PrecededBy", "type": "class", "doc": "<p>Lookbehind matching of the given parse expression.\n<code>PrecededBy</code> does not advance the parsing position within the\ninput string, it only verifies that the specified parse expression\nmatches prior to the current position.  <code>PrecededBy</code> always\nreturns a null token list, but if a results name is defined on the\ngiven expression, it is returned.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>expr - expression that must match prior to the current parse\nlocation</li>\n<li>retreat - (default= <code>None</code>) - (int) maximum number of characters\nto lookbehind prior to the current parse location</li>\n</ul>\n\n<p>If the lookbehind expression is a string, Literal, Keyword, or\na Word or CharsNotIn with a specified exact or maximum length, then\nthe retreat parameter is not required. Otherwise, retreat must be\nspecified to give a maximum number of characters to look back from\nthe current parse position for a lookbehind match.</p>\n\n<p>Example::</p>\n\n<pre><code># VB-style variable names with type prefixes\nint_var = PrecededBy(\"#\") + pyparsing_common.identifier\nstr_var = PrecededBy(\"$\") + pyparsing_common.identifier\n</code></pre>\n", "bases": "ParseElementEnhance"}, {"fullname": "x4i.pyparsing.PrecededBy.__init__", "modulename": "x4i.pyparsing", "qualname": "PrecededBy.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, expr, retreat=None)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.PrecededBy.parseImpl", "modulename": "x4i.pyparsing", "qualname": "PrecededBy.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc=0, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.MatchFirst", "modulename": "x4i.pyparsing", "qualname": "MatchFirst", "type": "class", "doc": "<p>Requires that at least one <code>ParseExpression</code> is found. If\ntwo expressions match, the first one listed is the one that will\nmatch. May be constructed using the <code>'|'</code> operator.</p>\n\n<p>Example::</p>\n\n<pre><code># construct MatchFirst using '|' operator\n\n# watch the order of expressions to match\nnumber = Word(nums) | Combine(Word(nums) + '.' + Word(nums))\nprint(number.searchString(\"123 3.1416 789\")) #  Fail! -&gt; [['123'], ['3'], ['1416'], ['789']]\n\n# put more selective expression first\nnumber = Combine(Word(nums) + '.' + Word(nums)) | Word(nums)\nprint(number.searchString(\"123 3.1416 789\")) #  Better -&gt; [['123'], ['3.1416'], ['789']]\n</code></pre>\n", "bases": "ParseExpression"}, {"fullname": "x4i.pyparsing.MatchFirst.__init__", "modulename": "x4i.pyparsing", "qualname": "MatchFirst.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, exprs, savelist=False)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.MatchFirst.parseImpl", "modulename": "x4i.pyparsing", "qualname": "MatchFirst.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.MatchFirst.checkRecursion", "modulename": "x4i.pyparsing", "qualname": "MatchFirst.checkRecursion", "type": "function", "doc": "<p></p>\n", "signature": "(self, parseElementList)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.NoMatch", "modulename": "x4i.pyparsing", "qualname": "NoMatch", "type": "class", "doc": "<p>A token that will never match.</p>\n", "bases": "Token"}, {"fullname": "x4i.pyparsing.NoMatch.__init__", "modulename": "x4i.pyparsing", "qualname": "NoMatch.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.NoMatch.parseImpl", "modulename": "x4i.pyparsing", "qualname": "NoMatch.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.NotAny", "modulename": "x4i.pyparsing", "qualname": "NotAny", "type": "class", "doc": "<p>Lookahead to disallow matching with the given parse expression.\n<code>NotAny</code> does <em>not</em> advance the parsing position within the\ninput string, it only verifies that the specified parse expression\ndoes <em>not</em> match at the current position.  Also, <code>NotAny</code> does\n<em>not</em> skip over leading whitespace. <code>NotAny</code> always returns\na null token list.  May be constructed using the '~' operator.</p>\n\n<p>Example::</p>\n\n<pre><code>AND, OR, NOT = map(CaselessKeyword, \"AND OR NOT\".split())\n\n# take care not to mistake keywords for identifiers\nident = ~(AND | OR | NOT) + Word(alphas)\nboolean_term = Optional(NOT) + ident\n\n# very crude boolean expression - to support parenthesis groups and\n# operation hierarchy, use infixNotation\nboolean_expr = boolean_term + ZeroOrMore((AND | OR) + boolean_term)\n\n# integers that are followed by \".\" are actually floats\ninteger = Word(nums) + ~Char(\".\")\n</code></pre>\n", "bases": "ParseElementEnhance"}, {"fullname": "x4i.pyparsing.NotAny.__init__", "modulename": "x4i.pyparsing", "qualname": "NotAny.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, expr)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.NotAny.parseImpl", "modulename": "x4i.pyparsing", "qualname": "NotAny.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.OneOrMore", "modulename": "x4i.pyparsing", "qualname": "OneOrMore", "type": "class", "doc": "<p>Repetition of one or more of the given expression.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>expr - expression that must match one or more times</li>\n<li>stopOn - (default= <code>None</code>) - expression for a terminating sentinel\n  (only required if the sentinel would ordinarily match the repetition\n  expression)</li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code>data_word = Word(alphas)\nlabel = data_word + FollowedBy(':')\nattr_expr = Group(label + Suppress(':') + OneOrMore(data_word).setParseAction(' '.join))\n\ntext = \"shape: SQUARE posn: upper left color: BLACK\"\nOneOrMore(attr_expr).parseString(text).pprint()  # Fail! read 'color' as data instead of next label -&gt; [['shape', 'SQUARE color']]\n\n# use stopOn attribute for OneOrMore to avoid reading label string as part of the data\nattr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))\nOneOrMore(attr_expr).parseString(text).pprint() # Better -&gt; [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'BLACK']]\n\n# could also be written as\n(attr_expr * (1,)).parseString(text).pprint()\n</code></pre>\n", "bases": "_MultipleMatch"}, {"fullname": "x4i.pyparsing.OnlyOnce", "modulename": "x4i.pyparsing", "qualname": "OnlyOnce", "type": "class", "doc": "<p>Wrapper for parse actions, to ensure they are only called once.</p>\n"}, {"fullname": "x4i.pyparsing.OnlyOnce.__init__", "modulename": "x4i.pyparsing", "qualname": "OnlyOnce.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, methodCall)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.OnlyOnce.reset", "modulename": "x4i.pyparsing", "qualname": "OnlyOnce.reset", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Optional", "modulename": "x4i.pyparsing", "qualname": "Optional", "type": "class", "doc": "<p>Optional matching of the given expression.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>expr - expression that must match zero or more times</li>\n<li>default (optional) - value to be returned if the optional expression is not found.</li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code># US postal code can be a 5-digit zip, plus optional 4-digit qualifier\nzip = Combine(Word(nums, exact=5) + Optional('-' + Word(nums, exact=4)))\nzip.runTests('''\n    # traditional ZIP code\n    12345\n\n    # ZIP+4 form\n    12101-0001\n\n    # invalid ZIP\n    98765-\n    ''')\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code># traditional ZIP code\n12345\n['12345']\n\n# ZIP+4 form\n12101-0001\n['12101-0001']\n\n# invalid ZIP\n98765-\n     ^\nFAIL: Expected end of text (at char 5), (line:1, col:6)\n</code></pre>\n", "bases": "ParseElementEnhance"}, {"fullname": "x4i.pyparsing.Optional.__init__", "modulename": "x4i.pyparsing", "qualname": "Optional.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, expr, default=<x4i.pyparsing._NullToken object>)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Optional.parseImpl", "modulename": "x4i.pyparsing", "qualname": "Optional.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Or", "modulename": "x4i.pyparsing", "qualname": "Or", "type": "class", "doc": "<p>Requires that at least one <code>ParseExpression</code> is found. If\ntwo expressions match, the expression that matches the longest\nstring will be used. May be constructed using the <code>'^'</code>\noperator.</p>\n\n<p>Example::</p>\n\n<pre><code># construct Or using '^' operator\n\nnumber = Word(nums) ^ Combine(Word(nums) + '.' + Word(nums))\nprint(number.searchString(\"123 3.1416 789\"))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>[['123'], ['3.1416'], ['789']]\n</code></pre>\n", "bases": "ParseExpression"}, {"fullname": "x4i.pyparsing.Or.__init__", "modulename": "x4i.pyparsing", "qualname": "Or.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, exprs, savelist=False)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Or.parseImpl", "modulename": "x4i.pyparsing", "qualname": "Or.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Or.checkRecursion", "modulename": "x4i.pyparsing", "qualname": "Or.checkRecursion", "type": "function", "doc": "<p></p>\n", "signature": "(self, parseElementList)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseBaseException", "modulename": "x4i.pyparsing", "qualname": "ParseBaseException", "type": "class", "doc": "<p>base exception class for all parsing runtime exceptions</p>\n", "bases": "builtins.Exception"}, {"fullname": "x4i.pyparsing.ParseBaseException.__init__", "modulename": "x4i.pyparsing", "qualname": "ParseBaseException.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, pstr, loc=0, msg=None, elem=None)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseBaseException.markInputline", "modulename": "x4i.pyparsing", "qualname": "ParseBaseException.markInputline", "type": "function", "doc": "<p>Extracts the exception line from the input string, and marks\nthe location of the exception with a special symbol.</p>\n", "signature": "(self, markerString='>!<')", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseElementEnhance", "modulename": "x4i.pyparsing", "qualname": "ParseElementEnhance", "type": "class", "doc": "<p>Abstract subclass of <code>ParserElement</code>, for combining and\npost-processing parsed tokens.</p>\n", "bases": "ParserElement"}, {"fullname": "x4i.pyparsing.ParseElementEnhance.__init__", "modulename": "x4i.pyparsing", "qualname": "ParseElementEnhance.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, expr, savelist=False)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseElementEnhance.parseImpl", "modulename": "x4i.pyparsing", "qualname": "ParseElementEnhance.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseElementEnhance.leaveWhitespace", "modulename": "x4i.pyparsing", "qualname": "ParseElementEnhance.leaveWhitespace", "type": "function", "doc": "<p>Disables the skipping of whitespace before matching the characters in the\n<code>ParserElement</code>'s defined pattern.  This is normally only used internally by\nthe pyparsing module, but may be needed in some whitespace-sensitive grammars.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseElementEnhance.ignore", "modulename": "x4i.pyparsing", "qualname": "ParseElementEnhance.ignore", "type": "function", "doc": "<p>Define expression to be ignored (e.g., comments) while doing pattern\nmatching; may be called repeatedly, to define multiple comment or other\nignorable patterns.</p>\n\n<p>Example::</p>\n\n<pre><code>patt = OneOrMore(Word(alphas))\npatt.parseString('ablaj /* comment */ lskjd') # -&gt; ['ablaj']\n\npatt.ignore(cStyleComment)\npatt.parseString('ablaj /* comment */ lskjd') # -&gt; ['ablaj', 'lskjd']\n</code></pre>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseElementEnhance.streamline", "modulename": "x4i.pyparsing", "qualname": "ParseElementEnhance.streamline", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseElementEnhance.checkRecursion", "modulename": "x4i.pyparsing", "qualname": "ParseElementEnhance.checkRecursion", "type": "function", "doc": "<p></p>\n", "signature": "(self, parseElementList)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseElementEnhance.validate", "modulename": "x4i.pyparsing", "qualname": "ParseElementEnhance.validate", "type": "function", "doc": "<p>Check defined expressions for valid structure, check for infinite recursive definitions.</p>\n", "signature": "(self, validateTrace=[])", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseException", "modulename": "x4i.pyparsing", "qualname": "ParseException", "type": "class", "doc": "<p>Exception thrown when parse expressions don't match class;\nsupported attributes by name are:</p>\n\n<ul>\n<li>lineno - returns the line number of the exception text</li>\n<li>col - returns the column number of the exception text</li>\n<li>line - returns the line containing the exception text</li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code>try:\n    Word(nums).setName(\"integer\").parseString(\"ABC\")\nexcept ParseException as pe:\n    print(pe)\n    print(\"column: {}\".format(pe.col))\n</code></pre>\n\n<p>prints::</p>\n\n<p>Expected integer (at char 0), (line:1, col:1)\n    column: 1</p>\n", "bases": "ParseBaseException"}, {"fullname": "x4i.pyparsing.ParseExpression", "modulename": "x4i.pyparsing", "qualname": "ParseExpression", "type": "class", "doc": "<p>Abstract subclass of ParserElement, for combining and\npost-processing parsed tokens.</p>\n", "bases": "ParserElement"}, {"fullname": "x4i.pyparsing.ParseExpression.__init__", "modulename": "x4i.pyparsing", "qualname": "ParseExpression.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, exprs, savelist=False)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseExpression.append", "modulename": "x4i.pyparsing", "qualname": "ParseExpression.append", "type": "function", "doc": "<p></p>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseExpression.leaveWhitespace", "modulename": "x4i.pyparsing", "qualname": "ParseExpression.leaveWhitespace", "type": "function", "doc": "<p>Extends <code>leaveWhitespace</code> defined in base class, and also invokes <code>leaveWhitespace</code> on\nall contained expressions.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseExpression.ignore", "modulename": "x4i.pyparsing", "qualname": "ParseExpression.ignore", "type": "function", "doc": "<p>Define expression to be ignored (e.g., comments) while doing pattern\nmatching; may be called repeatedly, to define multiple comment or other\nignorable patterns.</p>\n\n<p>Example::</p>\n\n<pre><code>patt = OneOrMore(Word(alphas))\npatt.parseString('ablaj /* comment */ lskjd') # -&gt; ['ablaj']\n\npatt.ignore(cStyleComment)\npatt.parseString('ablaj /* comment */ lskjd') # -&gt; ['ablaj', 'lskjd']\n</code></pre>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseExpression.streamline", "modulename": "x4i.pyparsing", "qualname": "ParseExpression.streamline", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseExpression.setResultsName", "modulename": "x4i.pyparsing", "qualname": "ParseExpression.setResultsName", "type": "function", "doc": "<p>Define name for referencing matching tokens as a nested attribute\nof the returned parse results.\nNOTE: this returns a <em>copy</em> of the original <code>ParserElement</code> object;\nthis is so that the client can define a basic element, such as an\ninteger, and reference it in multiple places with different names.</p>\n\n<p>You can also set results names using the abbreviated syntax,\n<code>expr(\"name\")</code> in place of <code>expr.setResultsName(\"name\")</code></p>\n\n<ul>\n<li>see <code>__call__</code>.</li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code>date_str = (integer.setResultsName(\"year\") + '/'\n            + integer.setResultsName(\"month\") + '/'\n            + integer.setResultsName(\"day\"))\n\n# equivalent form:\ndate_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n</code></pre>\n", "signature": "(self, name, listAllMatches=False)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseExpression.validate", "modulename": "x4i.pyparsing", "qualname": "ParseExpression.validate", "type": "function", "doc": "<p>Check defined expressions for valid structure, check for infinite recursive definitions.</p>\n", "signature": "(self, validateTrace=[])", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseExpression.copy", "modulename": "x4i.pyparsing", "qualname": "ParseExpression.copy", "type": "function", "doc": "<p>Make a copy of this <code>ParserElement</code>.  Useful for defining\ndifferent parse actions for the same parsing pattern, using copies of\nthe original parse element.</p>\n\n<p>Example::</p>\n\n<pre><code>integer = Word(nums).setParseAction(lambda toks: int(toks[0]))\nintegerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress(\"K\")\nintegerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress(\"M\")\n\nprint(OneOrMore(integerK | integerM | integer).parseString(\"5K 100 640K 256M\"))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>[5120, 100, 655360, 268435456]\n</code></pre>\n\n<p>Equivalent form of <code>expr.copy()</code> is just <code>expr()</code>::</p>\n\n<pre><code>integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress(\"M\")\n</code></pre>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseFatalException", "modulename": "x4i.pyparsing", "qualname": "ParseFatalException", "type": "class", "doc": "<p>user-throwable exception thrown when inconsistent parse content\nis found; stops all parsing immediately</p>\n", "bases": "ParseBaseException"}, {"fullname": "x4i.pyparsing.ParseResults", "modulename": "x4i.pyparsing", "qualname": "ParseResults", "type": "class", "doc": "<p>Structured parse results, to provide multiple means of access to\nthe parsed data:</p>\n\n<ul>\n<li>as a list (<code>len(results)</code>)</li>\n<li>by list index (<code>results[0], results[1]</code>, etc.)</li>\n<li>by attribute (<code>results.&lt;resultsName&gt;</code> - see <code>ParserElement.setResultsName</code>)</li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code>integer = Word(nums)\ndate_str = (integer.setResultsName(\"year\") + '/'\n                + integer.setResultsName(\"month\") + '/'\n                + integer.setResultsName(\"day\"))\n# equivalent form:\n# date_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n\n# parseString returns a ParseResults object\nresult = date_str.parseString(\"1999/12/31\")\n\ndef test(s, fn=repr):\n    print(\"%s -&gt; %s\" % (s, fn(eval(s))))\ntest(\"list(result)\")\ntest(\"result[0]\")\ntest(\"result['month']\")\ntest(\"result.day\")\ntest(\"'month' in result\")\ntest(\"'minutes' in result\")\ntest(\"result.dump()\", str)\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>list(result) -&gt; ['1999', '/', '12', '/', '31']\nresult[0] -&gt; '1999'\nresult['month'] -&gt; '12'\nresult.day -&gt; '31'\n'month' in result -&gt; True\n'minutes' in result -&gt; False\nresult.dump() -&gt; ['1999', '/', '12', '/', '31']\n- day: 31\n- month: 12\n- year: 1999\n</code></pre>\n"}, {"fullname": "x4i.pyparsing.ParseResults.__init__", "modulename": "x4i.pyparsing", "qualname": "ParseResults.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    toklist=None,\n    name=None,\n    asList=True,\n    modal=True,\n    isinstance=<built-in function isinstance>\n)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.haskeys", "modulename": "x4i.pyparsing", "qualname": "ParseResults.haskeys", "type": "function", "doc": "<p>Since keys() returns an iterator, this method is helpful in bypassing\ncode that looks for the existence of any defined results names.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.pop", "modulename": "x4i.pyparsing", "qualname": "ParseResults.pop", "type": "function", "doc": "<p>Removes and returns item at specified index (default= <code>last</code>).\nSupports both <code>list</code> and <code>dict</code> semantics for <code>pop()</code>. If\npassed no argument or an integer argument, it will use <code>list</code>\nsemantics and pop tokens from the list of parsed tokens. If passed\na non-integer argument (most likely a string), it will use <code>dict</code>\nsemantics and pop the corresponding value from any defined results\nnames. A second default return value argument is supported, just as in\n<code>dict.pop()</code>.</p>\n\n<p>Example::</p>\n\n<pre><code>def remove_first(tokens):\n    tokens.pop(0)\nprint(OneOrMore(Word(nums)).parseString(\"0 123 321\")) # -&gt; ['0', '123', '321']\nprint(OneOrMore(Word(nums)).addParseAction(remove_first).parseString(\"0 123 321\")) # -&gt; ['123', '321']\n\nlabel = Word(alphas)\npatt = label(\"LABEL\") + OneOrMore(Word(nums))\nprint(patt.parseString(\"AAB 123 321\").dump())\n\n# Use pop() in a parse action to remove named result (note that corresponding value is not\n# removed from list form of results)\ndef remove_LABEL(tokens):\n    tokens.pop(\"LABEL\")\n    return tokens\npatt.addParseAction(remove_LABEL)\nprint(patt.parseString(\"AAB 123 321\").dump())\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>['AAB', '123', '321']\n- LABEL: AAB\n\n['AAB', '123', '321']\n</code></pre>\n", "signature": "(self, *args, **kwargs)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.get", "modulename": "x4i.pyparsing", "qualname": "ParseResults.get", "type": "function", "doc": "<p>Returns named result matching the given key, or if there is no\nsuch name, then returns the given <code>defaultValue</code> or <code>None</code> if no\n<code>defaultValue</code> is specified.</p>\n\n<p>Similar to <code>dict.get()</code>.</p>\n\n<p>Example::</p>\n\n<pre><code>integer = Word(nums)\ndate_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n\nresult = date_str.parseString(\"1999/12/31\")\nprint(result.get(\"year\")) # -&gt; '1999'\nprint(result.get(\"hour\", \"not specified\")) # -&gt; 'not specified'\nprint(result.get(\"hour\")) # -&gt; None\n</code></pre>\n", "signature": "(self, key, defaultValue=None)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.insert", "modulename": "x4i.pyparsing", "qualname": "ParseResults.insert", "type": "function", "doc": "<p>Inserts new element at location index in the list of parsed tokens.</p>\n\n<p>Similar to <code>list.insert()</code>.</p>\n\n<p>Example::</p>\n\n<pre><code>print(OneOrMore(Word(nums)).parseString(\"0 123 321\")) # -&gt; ['0', '123', '321']\n\n# use a parse action to insert the parse location in the front of the parsed results\ndef insert_locn(locn, tokens):\n    tokens.insert(0, locn)\nprint(OneOrMore(Word(nums)).addParseAction(insert_locn).parseString(\"0 123 321\")) # -&gt; [0, '0', '123', '321']\n</code></pre>\n", "signature": "(self, index, insStr)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.append", "modulename": "x4i.pyparsing", "qualname": "ParseResults.append", "type": "function", "doc": "<p>Add single element to end of ParseResults list of elements.</p>\n\n<p>Example::</p>\n\n<pre><code>print(OneOrMore(Word(nums)).parseString(\"0 123 321\")) # -&gt; ['0', '123', '321']\n\n# use a parse action to compute the sum of the parsed integers, and add it to the end\ndef append_sum(tokens):\n    tokens.append(sum(map(int, tokens)))\nprint(OneOrMore(Word(nums)).addParseAction(append_sum).parseString(\"0 123 321\")) # -&gt; ['0', '123', '321', 444]\n</code></pre>\n", "signature": "(self, item)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.extend", "modulename": "x4i.pyparsing", "qualname": "ParseResults.extend", "type": "function", "doc": "<p>Add sequence of elements to end of ParseResults list of elements.</p>\n\n<p>Example::</p>\n\n<pre><code>patt = OneOrMore(Word(alphas))\n\n# use a parse action to append the reverse of the matched strings, to make a palindrome\ndef make_palindrome(tokens):\n    tokens.extend(reversed([t[::-1] for t in tokens]))\n    return ''.join(tokens)\nprint(patt.addParseAction(make_palindrome).parseString(\"lskdj sdlkjf lksd\")) # -&gt; 'lskdjsdlkjflksddsklfjkldsjdksl'\n</code></pre>\n", "signature": "(self, itemseq)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.clear", "modulename": "x4i.pyparsing", "qualname": "ParseResults.clear", "type": "function", "doc": "<p>Clear all elements and results names.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.asList", "modulename": "x4i.pyparsing", "qualname": "ParseResults.asList", "type": "function", "doc": "<p>Returns the parse results as a nested list of matching tokens, all converted to strings.</p>\n\n<p>Example::</p>\n\n<pre><code>patt = OneOrMore(Word(alphas))\nresult = patt.parseString(\"sldkj lsdkj sldkj\")\n# even though the result prints in string-like form, it is actually a pyparsing ParseResults\nprint(type(result), result) # -&gt; &lt;class 'pyparsing.ParseResults'&gt; ['sldkj', 'lsdkj', 'sldkj']\n\n# Use asList() to create an actual list\nresult_list = result.asList()\nprint(type(result_list), result_list) # -&gt; &lt;class 'list'&gt; ['sldkj', 'lsdkj', 'sldkj']\n</code></pre>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.asDict", "modulename": "x4i.pyparsing", "qualname": "ParseResults.asDict", "type": "function", "doc": "<p>Returns the named parse results as a nested dictionary.</p>\n\n<p>Example::</p>\n\n<pre><code>integer = Word(nums)\ndate_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n\nresult = date_str.parseString('12/31/1999')\nprint(type(result), repr(result)) # -&gt; &lt;class 'pyparsing.ParseResults'&gt; (['12', '/', '31', '/', '1999'], {'day': [('1999', 4)], 'year': [('12', 0)], 'month': [('31', 2)]})\n\nresult_dict = result.asDict()\nprint(type(result_dict), repr(result_dict)) # -&gt; &lt;class 'dict'&gt; {'day': '1999', 'year': '12', 'month': '31'}\n\n# even though a ParseResults supports dict-like access, sometime you just need to have a dict\nimport json\nprint(json.dumps(result)) # -&gt; Exception: TypeError: ... is not JSON serializable\nprint(json.dumps(result.asDict())) # -&gt; {\"month\": \"31\", \"day\": \"1999\", \"year\": \"12\"}\n</code></pre>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.copy", "modulename": "x4i.pyparsing", "qualname": "ParseResults.copy", "type": "function", "doc": "<p>Returns a new copy of a <code>ParseResults</code> object.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.asXML", "modulename": "x4i.pyparsing", "qualname": "ParseResults.asXML", "type": "function", "doc": "<p>(Deprecated) Returns the parse results as XML. Tags are created for tokens and lists that have defined results names.</p>\n", "signature": "(self, doctag=None, namedItemsOnly=False, indent='', formatted=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.getName", "modulename": "x4i.pyparsing", "qualname": "ParseResults.getName", "type": "function", "doc": "<p>Returns the results name for this token expression. Useful when several\ndifferent expressions might match at a particular location.</p>\n\n<p>Example::</p>\n\n<pre><code>integer = Word(nums)\nssn_expr = Regex(r\"\\d\\d\\d-\\d\\d-\\d\\d\\d\\d\")\nhouse_number_expr = Suppress('#') + Word(nums, alphanums)\nuser_data = (Group(house_number_expr)(\"house_number\")\n            | Group(ssn_expr)(\"ssn\")\n            | Group(integer)(\"age\"))\nuser_info = OneOrMore(user_data)\n\nresult = user_info.parseString(\"22 111-22-3333 #221B\")\nfor item in result:\n    print(item.getName(), ':', item[0])\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>age : 22\nssn : 111-22-3333\nhouse_number : 221B\n</code></pre>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.dump", "modulename": "x4i.pyparsing", "qualname": "ParseResults.dump", "type": "function", "doc": "<p>Diagnostic method for listing out the contents of\na <code>ParseResults</code>. Accepts an optional <code>indent</code> argument so\nthat this string can be embedded in a nested display of other data.</p>\n\n<p>Example::</p>\n\n<pre><code>integer = Word(nums)\ndate_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n\nresult = date_str.parseString('12/31/1999')\nprint(result.dump())\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>['12', '/', '31', '/', '1999']\n- day: 1999\n- month: 31\n- year: 12\n</code></pre>\n", "signature": "(self, indent='', depth=0, full=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.pprint", "modulename": "x4i.pyparsing", "qualname": "ParseResults.pprint", "type": "function", "doc": "<p>Pretty-printer for parsed results as a list, using the\n<a href=\"http://docs.python.org/3/library/pprint.html\">pprint </a> module.\nAccepts additional positional or keyword args as defined for\n<a href=\"http://docs.python.org/3/library/pprint.html#pprint.pprint\">pprint.pprint </a> .</p>\n\n<p>Example::</p>\n\n<pre><code>ident = Word(alphas, alphanums)\nnum = Word(nums)\nfunc = Forward()\nterm = ident | num | Group('(' + func + ')')\nfunc &lt;&lt;= ident + Group(Optional(delimitedList(term)))\nresult = func.parseString(\"fna a,b,(fnb c,d,200),100\")\nresult.pprint(width=40)\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>['fna',\n ['a',\n  'b',\n  ['(', 'fnb', ['c', 'd', '200'], ')'],\n  '100']]\n</code></pre>\n", "signature": "(self, *args, **kwargs)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.keys", "modulename": "x4i.pyparsing", "qualname": "ParseResults.keys", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.values", "modulename": "x4i.pyparsing", "qualname": "ParseResults.values", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseResults.items", "modulename": "x4i.pyparsing", "qualname": "ParseResults.items", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParseSyntaxException", "modulename": "x4i.pyparsing", "qualname": "ParseSyntaxException", "type": "class", "doc": "<p>just like <code>ParseFatalException</code>, but thrown internally\nwhen an <code>ErrorStop&lt;And._ErrorStop&gt;</code> ('-' operator) indicates\nthat parsing is to stop immediately because an unbacktrackable\nsyntax error has been found.</p>\n", "bases": "ParseFatalException"}, {"fullname": "x4i.pyparsing.ParserElement", "modulename": "x4i.pyparsing", "qualname": "ParserElement", "type": "class", "doc": "<p>Abstract base level parser element class.</p>\n"}, {"fullname": "x4i.pyparsing.ParserElement.__init__", "modulename": "x4i.pyparsing", "qualname": "ParserElement.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, savelist=False)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.DEFAULT_WHITE_CHARS", "modulename": "x4i.pyparsing", "qualname": "ParserElement.DEFAULT_WHITE_CHARS", "type": "variable", "doc": "<p></p>\n", "default_value": " = ' \\n\\t\\r'"}, {"fullname": "x4i.pyparsing.ParserElement.verbose_stacktrace", "modulename": "x4i.pyparsing", "qualname": "ParserElement.verbose_stacktrace", "type": "variable", "doc": "<p></p>\n", "default_value": " = False"}, {"fullname": "x4i.pyparsing.ParserElement.setDefaultWhitespaceChars", "modulename": "x4i.pyparsing", "qualname": "ParserElement.setDefaultWhitespaceChars", "type": "function", "doc": "<p>Overrides the default whitespace chars</p>\n\n<p>Example::</p>\n\n<pre><code># default whitespace chars are space, &lt;TAB&gt; and newline\nOneOrMore(Word(alphas)).parseString(\"abc def\\nghi jkl\")  # -&gt; ['abc', 'def', 'ghi', 'jkl']\n\n# change to just treat newline as significant\nParserElement.setDefaultWhitespaceChars(\" \\t\")\nOneOrMore(Word(alphas)).parseString(\"abc def\\nghi jkl\")  # -&gt; ['abc', 'def']\n</code></pre>\n", "signature": "(chars)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.inlineLiteralsUsing", "modulename": "x4i.pyparsing", "qualname": "ParserElement.inlineLiteralsUsing", "type": "function", "doc": "<p>Set class to be used for inclusion of string literals into a parser.</p>\n\n<p>Example::</p>\n\n<pre><code># default literal class used is Literal\ninteger = Word(nums)\ndate_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n\ndate_str.parseString(\"1999/12/31\")  # -&gt; ['1999', '/', '12', '/', '31']\n\n\n# change to Suppress\nParserElement.inlineLiteralsUsing(Suppress)\ndate_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n\ndate_str.parseString(\"1999/12/31\")  # -&gt; ['1999', '12', '31']\n</code></pre>\n", "signature": "(cls)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.copy", "modulename": "x4i.pyparsing", "qualname": "ParserElement.copy", "type": "function", "doc": "<p>Make a copy of this <code>ParserElement</code>.  Useful for defining\ndifferent parse actions for the same parsing pattern, using copies of\nthe original parse element.</p>\n\n<p>Example::</p>\n\n<pre><code>integer = Word(nums).setParseAction(lambda toks: int(toks[0]))\nintegerK = integer.copy().addParseAction(lambda toks: toks[0]*1024) + Suppress(\"K\")\nintegerM = integer.copy().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress(\"M\")\n\nprint(OneOrMore(integerK | integerM | integer).parseString(\"5K 100 640K 256M\"))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>[5120, 100, 655360, 268435456]\n</code></pre>\n\n<p>Equivalent form of <code>expr.copy()</code> is just <code>expr()</code>::</p>\n\n<pre><code>integerM = integer().addParseAction(lambda toks: toks[0]*1024*1024) + Suppress(\"M\")\n</code></pre>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.setName", "modulename": "x4i.pyparsing", "qualname": "ParserElement.setName", "type": "function", "doc": "<p>Define name for this expression, makes debugging and exception messages clearer.</p>\n\n<p>Example::</p>\n\n<pre><code>Word(nums).parseString(\"ABC\")  # -&gt; Exception: Expected W:(0123...) (at char 0), (line:1, col:1)\nWord(nums).setName(\"integer\").parseString(\"ABC\")  # -&gt; Exception: Expected integer (at char 0), (line:1, col:1)\n</code></pre>\n", "signature": "(self, name)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.setResultsName", "modulename": "x4i.pyparsing", "qualname": "ParserElement.setResultsName", "type": "function", "doc": "<p>Define name for referencing matching tokens as a nested attribute\nof the returned parse results.\nNOTE: this returns a <em>copy</em> of the original <code>ParserElement</code> object;\nthis is so that the client can define a basic element, such as an\ninteger, and reference it in multiple places with different names.</p>\n\n<p>You can also set results names using the abbreviated syntax,\n<code>expr(\"name\")</code> in place of <code>expr.setResultsName(\"name\")</code></p>\n\n<ul>\n<li>see <code>__call__</code>.</li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code>date_str = (integer.setResultsName(\"year\") + '/'\n            + integer.setResultsName(\"month\") + '/'\n            + integer.setResultsName(\"day\"))\n\n# equivalent form:\ndate_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n</code></pre>\n", "signature": "(self, name, listAllMatches=False)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.setBreak", "modulename": "x4i.pyparsing", "qualname": "ParserElement.setBreak", "type": "function", "doc": "<p>Method to invoke the Python pdb debugger when this element is\nabout to be parsed. Set <code>breakFlag</code> to True to enable, False to\ndisable.</p>\n", "signature": "(self, breakFlag=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.setParseAction", "modulename": "x4i.pyparsing", "qualname": "ParserElement.setParseAction", "type": "function", "doc": "<p>Define one or more actions to perform when successfully matching parse element definition.\nParse action fn is a callable method with 0-3 arguments, called as <code>fn(s,loc,toks)</code> ,\n<code>fn(loc,toks)</code> , <code>fn(toks)</code> , or just <code>fn()</code> , where:</p>\n\n<ul>\n<li>s   = the original string being parsed (see note below)</li>\n<li>loc = the location of the matching substring</li>\n<li>toks = a list of the matched tokens, packaged as a <code>ParseResults</code> object</li>\n</ul>\n\n<p>If the functions in fns modify the tokens, they can return them as the return\nvalue from fn, and the modified list of tokens will replace the original.\nOtherwise, fn does not need to return any value.</p>\n\n<p>Optional keyword arguments:</p>\n\n<ul>\n<li>callDuringTry = (default= <code>False</code> ) indicate if parse action should be run during lookaheads and alternate testing</li>\n</ul>\n\n<p>Note: the default parsing behavior is to expand tabs in the input string\nbefore starting the parsing process.  See `parseString for more\ninformation on parsing strings containing <code>&lt;TAB&gt;</code> s, and suggested\nmethods to maintain a consistent view of the parsed string, the parse\nlocation, and line and column positions within the parsed string.</p>\n\n<p>Example::</p>\n\n<pre><code>integer = Word(nums)\ndate_str = integer + '/' + integer + '/' + integer\n\ndate_str.parseString(\"1999/12/31\")  # -&gt; ['1999', '/', '12', '/', '31']\n\n# use parse action to convert to ints at parse time\ninteger = Word(nums).setParseAction(lambda toks: int(toks[0]))\ndate_str = integer + '/' + integer + '/' + integer\n\n# note that integer fields are now ints, not strings\ndate_str.parseString(\"1999/12/31\")  # -&gt; [1999, '/', 12, '/', 31]\n</code></pre>\n", "signature": "(self, *fns, **kwargs)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.addParseAction", "modulename": "x4i.pyparsing", "qualname": "ParserElement.addParseAction", "type": "function", "doc": "<p>Add one or more parse actions to expression's list of parse actions. See <code>setParseAction</code>.</p>\n\n<p>See examples in <code>copy</code>.</p>\n", "signature": "(self, *fns, **kwargs)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.addCondition", "modulename": "x4i.pyparsing", "qualname": "ParserElement.addCondition", "type": "function", "doc": "<p>Add a boolean predicate function to expression's list of parse actions. See\n<code>setParseAction</code> for function call signatures. Unlike <code>setParseAction</code>,\nfunctions passed to <code>addCondition</code> need to return boolean success/fail of the condition.</p>\n\n<p>Optional keyword arguments:</p>\n\n<ul>\n<li>message = define a custom message to be used in the raised exception</li>\n<li>fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException</li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code>integer = Word(nums).setParseAction(lambda toks: int(toks[0]))\nyear_int = integer.copy()\nyear_int.addCondition(lambda toks: toks[0] &gt;= 2000, message=\"Only support years 2000 and later\")\ndate_str = year_int + '/' + integer + '/' + integer\n\nresult = date_str.parseString(\"1999/12/31\")  # -&gt; Exception: Only support years 2000 and later (at char 0), (line:1, col:1)\n</code></pre>\n", "signature": "(self, *fns, **kwargs)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.setFailAction", "modulename": "x4i.pyparsing", "qualname": "ParserElement.setFailAction", "type": "function", "doc": "<p>Define action to perform if parsing fails at this expression.\nFail acton fn is a callable function that takes the arguments\n<code>fn(s,loc,expr,err)</code> where:</p>\n\n<ul>\n<li>s = string being parsed</li>\n<li>loc = location where expression match was attempted and failed</li>\n<li>expr = the parse expression that failed</li>\n<li>err = the exception thrown\nThe function returns no value.  It may throw <code>ParseFatalException</code>\nif it is desired to stop parsing immediately.</li>\n</ul>\n", "signature": "(self, fn)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.preParse", "modulename": "x4i.pyparsing", "qualname": "ParserElement.preParse", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.parseImpl", "modulename": "x4i.pyparsing", "qualname": "ParserElement.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.postParse", "modulename": "x4i.pyparsing", "qualname": "ParserElement.postParse", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, tokenlist)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.tryParse", "modulename": "x4i.pyparsing", "qualname": "ParserElement.tryParse", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.canParseNext", "modulename": "x4i.pyparsing", "qualname": "ParserElement.canParseNext", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.packrat_cache", "modulename": "x4i.pyparsing", "qualname": "ParserElement.packrat_cache", "type": "variable", "doc": "<p></p>\n", "default_value": " = {}"}, {"fullname": "x4i.pyparsing.ParserElement.packrat_cache_lock", "modulename": "x4i.pyparsing", "qualname": "ParserElement.packrat_cache_lock", "type": "variable", "doc": "<p></p>\n", "default_value": " = <unlocked _thread.RLock object owner=0 count=0>"}, {"fullname": "x4i.pyparsing.ParserElement.packrat_cache_stats", "modulename": "x4i.pyparsing", "qualname": "ParserElement.packrat_cache_stats", "type": "variable", "doc": "<p></p>\n", "default_value": " = [0, 0]"}, {"fullname": "x4i.pyparsing.ParserElement.resetCache", "modulename": "x4i.pyparsing", "qualname": "ParserElement.resetCache", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.enablePackrat", "modulename": "x4i.pyparsing", "qualname": "ParserElement.enablePackrat", "type": "function", "doc": "<p>Enables \"packrat\" parsing, which adds memoizing to the parsing logic.\nRepeated parse attempts at the same string location (which happens\noften in many complex grammars) can immediately return a cached value,\ninstead of re-executing parsing/validating code.  Memoizing is done of\nboth valid results and parsing exceptions.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>cache_size_limit - (default= <code>128</code>) - if an integer value is provided\nwill limit the size of the packrat cache; if None is passed, then\nthe cache size will be unbounded; if 0 is passed, the cache will\nbe effectively disabled.</li>\n</ul>\n\n<p>This speedup may break existing programs that use parse actions that\nhave side-effects.  For this reason, packrat parsing is disabled when\nyou first import pyparsing.  To activate the packrat feature, your\nprogram must call the class method <code>ParserElement.enablePackrat</code>.  If\nyour program uses <code>psyco</code> to \"compile as you go\", you must call\n<code>enablePackrat</code> before calling <code>psyco.full()</code>.  If you do not do this,\nPython will crash.  For best results, call <code>enablePackrat()</code> immediately\nafter importing pyparsing.</p>\n\n<p>Example::</p>\n\n<pre><code>import pyparsing\npyparsing.ParserElement.enablePackrat()\n</code></pre>\n", "signature": "(cache_size_limit=128)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.parseString", "modulename": "x4i.pyparsing", "qualname": "ParserElement.parseString", "type": "function", "doc": "<p>Execute the parse expression with the given string.\nThis is the main interface to the client code, once the complete\nexpression has been built.</p>\n\n<p>If you want the grammar to require that the entire input string be\nsuccessfully parsed, then set <code>parseAll</code> to True (equivalent to ending\nthe grammar with <code>StringEnd()</code>).</p>\n\n<p>Note: <code>parseString</code> implicitly calls <code>expandtabs()</code> on the input string,\nin order to report proper column numbers in parse actions.\nIf the input string contains tabs and\nthe grammar uses parse actions that use the <code>loc</code> argument to index into the\nstring being parsed, you can ensure you have a consistent view of the input\nstring by:</p>\n\n<ul>\n<li>calling <code>parseWithTabs</code> on your grammar before calling <code>parseString</code>\n(see <code>parseWithTabs</code>)</li>\n<li>define your parse action using the full <code>(s,loc,toks)</code> signature, and\nreference the input string using the parse action's <code>s</code> argument</li>\n<li>explictly expand the tabs in your input string before calling\n<code>parseString</code></li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code>Word('a').parseString('aaaaabaaa')  # -&gt; ['aaaaa']\nWord('a').parseString('aaaaabaaa', parseAll=True)  # -&gt; Exception: Expected end of text\n</code></pre>\n", "signature": "(self, instring, parseAll=False)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.scanString", "modulename": "x4i.pyparsing", "qualname": "ParserElement.scanString", "type": "function", "doc": "<p>Scan the input string for expression matches.  Each match will return the\nmatching tokens, start location, and end location.  May be called with optional\n<code>maxMatches</code> argument, to clip scanning after 'n' matches are found.  If\n<code>overlap</code> is specified, then overlapping matches will be reported.</p>\n\n<p>Note that the start and end locations are reported relative to the string\nbeing parsed.  See <code>parseString</code> for more information on parsing\nstrings with embedded tabs.</p>\n\n<p>Example::</p>\n\n<pre><code>source = \"sldjf123lsdjjkf345sldkjf879lkjsfd987\"\nprint(source)\nfor tokens,start,end in Word(alphas).scanString(source):\n    print(' '*start + '^'*(end-start))\n    print(' '*start + tokens[0])\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>sldjf123lsdjjkf345sldkjf879lkjsfd987\n^^^^^\nsldjf\n        ^^^^^^^\n        lsdjjkf\n                  ^^^^^^\n                  sldkjf\n                           ^^^^^^\n                           lkjsfd\n</code></pre>\n", "signature": "(self, instring, maxMatches=9223372036854775807, overlap=False)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.transformString", "modulename": "x4i.pyparsing", "qualname": "ParserElement.transformString", "type": "function", "doc": "<p>Extension to <code>scanString</code>, to modify matching text with modified tokens that may\nbe returned from a parse action.  To use <code>transformString</code>, define a grammar and\nattach a parse action to it that modifies the returned token list.\nInvoking <code>transformString()</code> on a target string will then scan for matches,\nand replace the matched text patterns according to the logic in the parse\naction.  <code>transformString()</code> returns the resulting transformed string.</p>\n\n<p>Example::</p>\n\n<pre><code>wd = Word(alphas)\nwd.setParseAction(lambda toks: toks[0].title())\n\nprint(wd.transformString(\"now is the winter of our discontent made glorious summer by this sun of york.\"))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.\n</code></pre>\n", "signature": "(self, instring)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.searchString", "modulename": "x4i.pyparsing", "qualname": "ParserElement.searchString", "type": "function", "doc": "<p>Another extension to <code>scanString</code>, simplifying the access to the tokens found\nto match the given parse expression.  May be called with optional\n<code>maxMatches</code> argument, to clip searching after 'n' matches are found.</p>\n\n<p>Example::</p>\n\n<pre><code># a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters\ncap_word = Word(alphas.upper(), alphas.lower())\n\nprint(cap_word.searchString(\"More than Iron, more than Lead, more than Gold I need Electricity\"))\n\n# the sum() builtin can be used to merge results into a single ParseResults object\nprint(sum(cap_word.searchString(\"More than Iron, more than Lead, more than Gold I need Electricity\")))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>[['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]\n['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']\n</code></pre>\n", "signature": "(self, instring, maxMatches=9223372036854775807)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.split", "modulename": "x4i.pyparsing", "qualname": "ParserElement.split", "type": "function", "doc": "<p>Generator method to split a string using the given expression as a separator.\nMay be called with optional <code>maxsplit</code> argument, to limit the number of splits;\nand the optional <code>includeSeparators</code> argument (default= <code>False</code>), if the separating\nmatching text should be included in the split results.</p>\n\n<p>Example::</p>\n\n<pre><code>punc = oneOf(list(\".,;:/-!?\"))\nprint(list(punc.split(\"This, this?, this sentence, is badly punctuated!\")))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>['This', ' this', '', ' this sentence', ' is badly punctuated', '']\n</code></pre>\n", "signature": "(\n    self,\n    instring,\n    maxsplit=9223372036854775807,\n    includeSeparators=False\n)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.suppress", "modulename": "x4i.pyparsing", "qualname": "ParserElement.suppress", "type": "function", "doc": "<p>Suppresses the output of this <code>ParserElement</code>; useful to keep punctuation from\ncluttering up returned output.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.leaveWhitespace", "modulename": "x4i.pyparsing", "qualname": "ParserElement.leaveWhitespace", "type": "function", "doc": "<p>Disables the skipping of whitespace before matching the characters in the\n<code>ParserElement</code>'s defined pattern.  This is normally only used internally by\nthe pyparsing module, but may be needed in some whitespace-sensitive grammars.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.setWhitespaceChars", "modulename": "x4i.pyparsing", "qualname": "ParserElement.setWhitespaceChars", "type": "function", "doc": "<p>Overrides the default whitespace chars</p>\n", "signature": "(self, chars)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.parseWithTabs", "modulename": "x4i.pyparsing", "qualname": "ParserElement.parseWithTabs", "type": "function", "doc": "<p>Overrides default behavior to expand <code>&lt;TAB&gt;</code>s to spaces before parsing the input string.\nMust be called before <code>parseString</code> when the input grammar contains elements that\nmatch <code>&lt;TAB&gt;</code> characters.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.ignore", "modulename": "x4i.pyparsing", "qualname": "ParserElement.ignore", "type": "function", "doc": "<p>Define expression to be ignored (e.g., comments) while doing pattern\nmatching; may be called repeatedly, to define multiple comment or other\nignorable patterns.</p>\n\n<p>Example::</p>\n\n<pre><code>patt = OneOrMore(Word(alphas))\npatt.parseString('ablaj /* comment */ lskjd') # -&gt; ['ablaj']\n\npatt.ignore(cStyleComment)\npatt.parseString('ablaj /* comment */ lskjd') # -&gt; ['ablaj', 'lskjd']\n</code></pre>\n", "signature": "(self, other)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.setDebugActions", "modulename": "x4i.pyparsing", "qualname": "ParserElement.setDebugActions", "type": "function", "doc": "<p>Enable display of debugging messages while doing pattern matching.</p>\n", "signature": "(self, startAction, successAction, exceptionAction)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.setDebug", "modulename": "x4i.pyparsing", "qualname": "ParserElement.setDebug", "type": "function", "doc": "<p>Enable display of debugging messages while doing pattern matching.\nSet <code>flag</code> to True to enable, False to disable.</p>\n\n<p>Example::</p>\n\n<pre><code>wd = Word(alphas).setName(\"alphaword\")\ninteger = Word(nums).setName(\"numword\")\nterm = wd | integer\n\n# turn on debugging for wd\nwd.setDebug()\n\nOneOrMore(term).parseString(\"abc 123 xyz 890\")\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>Match alphaword at loc 0(1,1)\nMatched alphaword -&gt; ['abc']\nMatch alphaword at loc 3(1,4)\nException raised:Expected alphaword (at char 4), (line:1, col:5)\nMatch alphaword at loc 7(1,8)\nMatched alphaword -&gt; ['xyz']\nMatch alphaword at loc 11(1,12)\nException raised:Expected alphaword (at char 12), (line:1, col:13)\nMatch alphaword at loc 15(1,16)\nException raised:Expected alphaword (at char 15), (line:1, col:16)\n</code></pre>\n\n<p>The output shown is that produced by the default debug actions - custom debug actions can be\nspecified using <code>setDebugActions</code>. Prior to attempting\nto match the <code>wd</code> expression, the debugging message <code>\"Match &lt;exprname&gt; at loc &lt;n&gt;(&lt;line&gt;,&lt;col&gt;)\"</code>\nis shown. Then if the parse succeeds, a <code>\"Matched\"` message is shown, or an</code>\"Exception raised\"<code>\nmessage is shown. Also note the use of `setName` to assign a human-readable name to the expression,\nwhich makes debugging and exception messages easier to understand - for instance, the default\nname created for the `Word` expression without calling</code>setName<code>is</code>\"W:(ABCD...)\"``.</p>\n", "signature": "(self, flag=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.streamline", "modulename": "x4i.pyparsing", "qualname": "ParserElement.streamline", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.checkRecursion", "modulename": "x4i.pyparsing", "qualname": "ParserElement.checkRecursion", "type": "function", "doc": "<p></p>\n", "signature": "(self, parseElementList)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.validate", "modulename": "x4i.pyparsing", "qualname": "ParserElement.validate", "type": "function", "doc": "<p>Check defined expressions for valid structure, check for infinite recursive definitions.</p>\n", "signature": "(self, validateTrace=[])", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.parseFile", "modulename": "x4i.pyparsing", "qualname": "ParserElement.parseFile", "type": "function", "doc": "<p>Execute the parse expression on the given file or filename.\nIf a filename is specified (instead of a file object),\nthe entire file is opened, read, and closed before parsing.</p>\n", "signature": "(self, file_or_filename, parseAll=False)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.matches", "modulename": "x4i.pyparsing", "qualname": "ParserElement.matches", "type": "function", "doc": "<p>Method for quick testing of a parser against a test string. Good for simple\ninline microtests of sub expressions while building up larger parser.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>testString - to test against this expression for a match</li>\n<li>parseAll - (default= <code>True</code>) - flag to pass to <code>parseString</code> when running tests</li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code>expr = Word(nums)\nassert expr.matches(\"100\")\n</code></pre>\n", "signature": "(self, testString, parseAll=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ParserElement.runTests", "modulename": "x4i.pyparsing", "qualname": "ParserElement.runTests", "type": "function", "doc": "<p>Execute the parse expression on a series of test strings, showing each\ntest, the parsed results or where the parse failed. Quick and easy way to\nrun a parse expression against a list of sample strings.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>tests - a list of separate test strings, or a multiline string of test strings</li>\n<li>parseAll - (default= <code>True</code> ) - flag to pass to <code>parseString</code> when running tests</li>\n<li>comment - (default= <code>'#'</code> ) - expression for indicating embedded comments in the test\n  string; pass None to disable comment filtering</li>\n<li>fullDump - (default= <code>True</code> ) - dump results as list followed by results names in nested outline;\n  if False, only dump nested list</li>\n<li>printResults - (default= <code>True</code> ) prints test output to stdout</li>\n<li>failureTests - (default= <code>False</code> ) indicates if these tests are expected to fail parsing</li>\n</ul>\n\n<p>Returns: a (success, results) tuple, where success indicates that all tests succeeded\n(or failed if <code>failureTests</code> is True), and the results contain a list of lines of each\ntest's output</p>\n\n<p>Example::</p>\n\n<pre><code>number_expr = pyparsing_common.number.copy()\n\nresult = number_expr.runTests('''\n    # unsigned integer\n    100\n    # negative integer\n    -100\n    # float with scientific notation\n    6.02e23\n    # integer with scientific notation\n    1e-12\n    ''')\nprint(\"Success\" if result[0] else \"Failed!\")\n\nresult = number_expr.runTests('''\n    # stray character\n    100Z\n    # missing leading digit before '.'\n    -.100\n    # too many '.'\n    3.14.159\n    ''', failureTests=True)\nprint(\"Success\" if result[0] else \"Failed!\")\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code># unsigned integer\n100\n[100]\n\n# negative integer\n-100\n[-100]\n\n# float with scientific notation\n6.02e23\n[6.02e+23]\n\n# integer with scientific notation\n1e-12\n[1e-12]\n\nSuccess\n\n# stray character\n100Z\n   ^\nFAIL: Expected end of text (at char 3), (line:1, col:4)\n\n# missing leading digit before '.'\n-.100\n^\nFAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)\n\n# too many '.'\n3.14.159\n    ^\nFAIL: Expected end of text (at char 4), (line:1, col:5)\n\nSuccess\n</code></pre>\n\n<p>Each test string must be on a single line. If you want to test a string that spans multiple\nlines, create a test like this::</p>\n\n<pre><code>expr.runTest(r\"this is a test\\n of strings that spans \\n 3 lines\")\n</code></pre>\n\n<p>(Note that this is a raw string literal, you must include the leading 'r'.)</p>\n", "signature": "(\n    self,\n    tests,\n    parseAll=True,\n    comment='#',\n    fullDump=True,\n    printResults=True,\n    failureTests=False\n)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.QuotedString", "modulename": "x4i.pyparsing", "qualname": "QuotedString", "type": "class", "doc": "<p>Token for matching strings that are delimited by quoting characters.</p>\n\n<p>Defined with the following parameters:</p>\n\n<pre><code>- quoteChar - string of one or more characters defining the\n  quote delimiting string\n- escChar - character to escape quotes, typically backslash\n  (default= ``None`` )\n- escQuote - special quote sequence to escape an embedded quote\n  string (such as SQL's ``\"\"`` to escape an embedded ``\"``)\n  (default= ``None`` )\n- multiline - boolean indicating whether quotes can span\n  multiple lines (default= ``False`` )\n- unquoteResults - boolean indicating whether the matched text\n  should be unquoted (default= ``True`` )\n- endQuoteChar - string of one or more characters defining the\n  end of the quote delimited string (default= ``None``  =&gt; same as\n  quoteChar)\n- convertWhitespaceEscapes - convert escaped whitespace\n  (``'\\t'``, ``'\\n'``, etc.) to actual whitespace\n  (default= ``True`` )\n</code></pre>\n\n<p>Example::</p>\n\n<pre><code>qs = QuotedString('\"')\nprint(qs.searchString('lsjdf \"This is the quote\" sldjf'))\ncomplex_qs = QuotedString('{{', endQuoteChar='}}')\nprint(complex_qs.searchString('lsjdf {{This is the \"quote\"}} sldjf'))\nsql_qs = QuotedString('\"', escQuote='\"\"')\nprint(sql_qs.searchString('lsjdf \"This is the quote with \"\"embedded\"\" quotes\" sldjf'))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>[['This is the quote']]\n[['This is the \"quote\"']]\n[['This is the quote with \"embedded\" quotes']]\n</code></pre>\n", "bases": "Token"}, {"fullname": "x4i.pyparsing.QuotedString.__init__", "modulename": "x4i.pyparsing", "qualname": "QuotedString.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    quoteChar,\n    escChar=None,\n    escQuote=None,\n    multiline=False,\n    unquoteResults=True,\n    endQuoteChar=None,\n    convertWhitespaceEscapes=True\n)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.QuotedString.parseImpl", "modulename": "x4i.pyparsing", "qualname": "QuotedString.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.RecursiveGrammarException", "modulename": "x4i.pyparsing", "qualname": "RecursiveGrammarException", "type": "class", "doc": "<p>exception thrown by <code>ParserElement.validate</code> if the\ngrammar could be improperly recursive</p>\n", "bases": "builtins.Exception"}, {"fullname": "x4i.pyparsing.RecursiveGrammarException.__init__", "modulename": "x4i.pyparsing", "qualname": "RecursiveGrammarException.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, parseElementList)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Regex", "modulename": "x4i.pyparsing", "qualname": "Regex", "type": "class", "doc": "<p>Token for matching strings that match a given regular\nexpression. Defined with string specifying the regular expression in\na form recognized by the stdlib Python  <a href=\"http://docs.python.org/3/library/re.html\">re module </a>.\nIf the given regex contains named groups (defined using <code>(?P&lt;name&gt;...)</code>),\nthese will be preserved as named parse results.</p>\n\n<p>Example::</p>\n\n<pre><code>realnum = Regex(r\"[+-]?\\d+\\.\\d*\")\ndate = Regex(r'(?P&lt;year&gt;\\d{4})-(?P&lt;month&gt;\\d\\d?)-(?P&lt;day&gt;\\d\\d?)')\n# ref: http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression\nroman = Regex(r\"M{0,4}(CM|CD|D?{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})\")\n</code></pre>\n", "bases": "Token"}, {"fullname": "x4i.pyparsing.Regex.__init__", "modulename": "x4i.pyparsing", "qualname": "Regex.__init__", "type": "function", "doc": "<p>The parameters <code>pattern</code> and <code>flags</code> are passed\nto the <code>re.compile()</code> function as-is. See the Python\n<a href=\"http://docs.python.org/3/library/re.html\">re module </a> module for an\nexplanation of the acceptable patterns and flags.</p>\n", "signature": "(self, pattern, flags=0, asGroupList=False, asMatch=False)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Regex.compiledREtype", "modulename": "x4i.pyparsing", "qualname": "Regex.compiledREtype", "type": "class", "doc": "<p>Compiled regular expression object.</p>\n"}, {"fullname": "x4i.pyparsing.Regex.parseImpl", "modulename": "x4i.pyparsing", "qualname": "Regex.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Regex.sub", "modulename": "x4i.pyparsing", "qualname": "Regex.sub", "type": "function", "doc": "<p>Return Regex with an attached parse action to transform the parsed\nresult as if called using <a href=\"https://docs.python.org/3/library/re.html#re.sub\">re.sub(expr, repl, string) </a>.</p>\n\n<p>Example::</p>\n\n<pre><code>make_html = Regex(r\"(\\w+):(.*?):\").sub(r\"&lt;\u0001&gt;\u0002&lt;/\u0001&gt;\")\nprint(make_html.transformString(\"h1:main title:\"))\n# prints \"&lt;h1&gt;main title&lt;/h1&gt;\"\n</code></pre>\n", "signature": "(self, repl)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.SkipTo", "modulename": "x4i.pyparsing", "qualname": "SkipTo", "type": "class", "doc": "<p>Token for skipping over all undefined text until the matched\nexpression is found.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>expr - target expression marking the end of the data to be skipped</li>\n<li>include - (default= <code>False</code>) if True, the target expression is also parsed\n  (the skipped text and target expression are returned as a 2-element list).</li>\n<li>ignore - (default= <code>None</code>) used to define grammars (typically quoted strings and\n  comments) that might contain false matches to the target expression</li>\n<li>failOn - (default= <code>None</code>) define expressions that are not allowed to be\n  included in the skipped test; if found before the target expression is found,\n  the SkipTo is not a match</li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code>report = '''\n    Outstanding Issues Report - 1 Jan 2000\n\n       # | Severity | Description                               |  Days Open\n    -----+----------+-------------------------------------------+-----------\n     101 | Critical | Intermittent system crash                 |          6\n      94 | Cosmetic | Spelling error on Login ('log|n')         |         14\n      79 | Minor    | System slow when running too many reports |         47\n    '''\ninteger = Word(nums)\nSEP = Suppress('|')\n# use SkipTo to simply match everything up until the next SEP\n# - ignore quoted strings, so that a '|' character inside a quoted string does not match\n# - parse action will call token.strip() for each matched token, i.e., the description body\nstring_data = SkipTo(SEP, ignore=quotedString)\nstring_data.setParseAction(tokenMap(str.strip))\nticket_expr = (integer(\"issue_num\") + SEP\n              + string_data(\"sev\") + SEP\n              + string_data(\"desc\") + SEP\n              + integer(\"days_open\"))\n\nfor tkt in ticket_expr.searchString(report):\n    print tkt.dump()\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>['101', 'Critical', 'Intermittent system crash', '6']\n- days_open: 6\n- desc: Intermittent system crash\n- issue_num: 101\n- sev: Critical\n['94', 'Cosmetic', \"Spelling error on Login ('log|n')\", '14']\n- days_open: 14\n- desc: Spelling error on Login ('log|n')\n- issue_num: 94\n- sev: Cosmetic\n['79', 'Minor', 'System slow when running too many reports', '47']\n- days_open: 47\n- desc: System slow when running too many reports\n- issue_num: 79\n- sev: Minor\n</code></pre>\n", "bases": "ParseElementEnhance"}, {"fullname": "x4i.pyparsing.SkipTo.__init__", "modulename": "x4i.pyparsing", "qualname": "SkipTo.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, other, include=False, ignore=None, failOn=None)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.SkipTo.parseImpl", "modulename": "x4i.pyparsing", "qualname": "SkipTo.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.StringEnd", "modulename": "x4i.pyparsing", "qualname": "StringEnd", "type": "class", "doc": "<p>Matches if current position is at the end of the parse string</p>\n", "bases": "_PositionToken"}, {"fullname": "x4i.pyparsing.StringEnd.__init__", "modulename": "x4i.pyparsing", "qualname": "StringEnd.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.StringEnd.parseImpl", "modulename": "x4i.pyparsing", "qualname": "StringEnd.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.StringStart", "modulename": "x4i.pyparsing", "qualname": "StringStart", "type": "class", "doc": "<p>Matches if current position is at the beginning of the parse\nstring</p>\n", "bases": "_PositionToken"}, {"fullname": "x4i.pyparsing.StringStart.__init__", "modulename": "x4i.pyparsing", "qualname": "StringStart.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.StringStart.parseImpl", "modulename": "x4i.pyparsing", "qualname": "StringStart.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Suppress", "modulename": "x4i.pyparsing", "qualname": "Suppress", "type": "class", "doc": "<p>Converter for ignoring the results of a parsed expression.</p>\n\n<p>Example::</p>\n\n<pre><code>source = \"a, b, c,d\"\nwd = Word(alphas)\nwd_list1 = wd + ZeroOrMore(',' + wd)\nprint(wd_list1.parseString(source))\n\n# often, delimiters that are useful during parsing are just in the\n# way afterward - use Suppress to keep them out of the parsed output\nwd_list2 = wd + ZeroOrMore(Suppress(',') + wd)\nprint(wd_list2.parseString(source))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>['a', ',', 'b', ',', 'c', ',', 'd']\n['a', 'b', 'c', 'd']\n</code></pre>\n\n<p>(See also <code>delimitedList</code>.)</p>\n", "bases": "TokenConverter"}, {"fullname": "x4i.pyparsing.Suppress.postParse", "modulename": "x4i.pyparsing", "qualname": "Suppress.postParse", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, tokenlist)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Suppress.suppress", "modulename": "x4i.pyparsing", "qualname": "Suppress.suppress", "type": "function", "doc": "<p>Suppresses the output of this <code>ParserElement</code>; useful to keep punctuation from\ncluttering up returned output.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Token", "modulename": "x4i.pyparsing", "qualname": "Token", "type": "class", "doc": "<p>Abstract <code>ParserElement</code> subclass, for defining atomic\nmatching patterns.</p>\n", "bases": "ParserElement"}, {"fullname": "x4i.pyparsing.Token.__init__", "modulename": "x4i.pyparsing", "qualname": "Token.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.TokenConverter", "modulename": "x4i.pyparsing", "qualname": "TokenConverter", "type": "class", "doc": "<p>Abstract subclass of <code>ParseExpression</code>, for converting parsed results.</p>\n", "bases": "ParseElementEnhance"}, {"fullname": "x4i.pyparsing.TokenConverter.__init__", "modulename": "x4i.pyparsing", "qualname": "TokenConverter.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, expr, savelist=False)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.White", "modulename": "x4i.pyparsing", "qualname": "White", "type": "class", "doc": "<p>Special matching class for matching whitespace.  Normally,\nwhitespace is ignored by pyparsing grammars.  This class is included\nwhen some whitespace structures are significant.  Define with\na string containing the whitespace characters to be matched; default\nis <code>\" \\t\\r\\n\"</code>.  Also takes optional <code>min</code>,\n<code>max</code>, and <code>exact</code> arguments, as defined for the\n<code>Word</code> class.</p>\n", "bases": "Token"}, {"fullname": "x4i.pyparsing.White.__init__", "modulename": "x4i.pyparsing", "qualname": "White.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, ws=' \\t\\r\\n', min=1, max=0, exact=0)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.White.whiteStrs", "modulename": "x4i.pyparsing", "qualname": "White.whiteStrs", "type": "variable", "doc": "<p></p>\n", "default_value": " = {' ': '<SPC>', '\\t': '<TAB>', '\\n': '<LF>', '\\r': '<CR>', '\\x0c': '<FF>'}"}, {"fullname": "x4i.pyparsing.White.parseImpl", "modulename": "x4i.pyparsing", "qualname": "White.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Word", "modulename": "x4i.pyparsing", "qualname": "Word", "type": "class", "doc": "<p>Token for matching words composed of allowed character sets.\nDefined with string containing all allowed initial characters, an\noptional string containing allowed body characters (if omitted,\ndefaults to the initial character set), and an optional minimum,\nmaximum, and/or exact length.  The default value for <code>min</code> is\n1 (a minimum value &lt; 1 is not valid); the default values for\n<code>max</code> and <code>exact</code> are 0, meaning no maximum or exact\nlength restriction. An optional <code>excludeChars</code> parameter can\nlist characters that might be found in the input <code>bodyChars</code>\nstring; useful to define a word of all printables except for one or\ntwo characters, for instance.</p>\n\n<p><code>srange</code> is useful for defining custom character set strings\nfor defining <code>Word</code> expressions, using range notation from\nregular expression character sets.</p>\n\n<p>A common mistake is to use <code>Word</code> to match a specific literal\nstring, as in <code>Word(\"Address\")</code>. Remember that <code>Word</code>\nuses the string argument to define <em>sets</em> of matchable characters.\nThis expression would match \"Add\", \"AAA\", \"dAred\", or any other word\nmade up of the characters 'A', 'd', 'r', 'e', and 's'. To match an\nexact literal string, use <code>Literal</code> or <code>Keyword</code>.</p>\n\n<p>pyparsing includes helper strings for building Words:</p>\n\n<ul>\n<li><code>alphas</code></li>\n<li><code>nums</code></li>\n<li><code>alphanums</code></li>\n<li><code>hexnums</code></li>\n<li><code>alphas8bit</code> (alphabetic characters in ASCII range 128-255\n<ul>\n<li>accented, tilded, umlauted, etc.)</li>\n</ul></li>\n<li><code>punc8bit</code> (non-alphabetic characters in ASCII range\n128-255 - currency, symbols, superscripts, diacriticals, etc.)</li>\n<li><code>printables</code> (any non-whitespace character)</li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code># a word composed of digits\ninteger = Word(nums) # equivalent to Word(\"0123456789\") or Word(srange(\"0-9\"))\n\n# a word with a leading capital, and zero or more lowercase\ncapital_word = Word(alphas.upper(), alphas.lower())\n\n# hostnames are alphanumeric, with leading alpha, and '-'\nhostname = Word(alphas, alphanums+'-')\n\n# roman numeral (not a strict parser, accepts invalid mix of characters)\nroman = Word(\"IVXLCDM\")\n\n# any string of non-whitespace characters, except for ','\ncsv_value = Word(printables, excludeChars=\",\")\n</code></pre>\n", "bases": "Token"}, {"fullname": "x4i.pyparsing.Word.__init__", "modulename": "x4i.pyparsing", "qualname": "Word.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    initChars,\n    bodyChars=None,\n    min=1,\n    max=0,\n    exact=0,\n    asKeyword=False,\n    excludeChars=None\n)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Word.parseImpl", "modulename": "x4i.pyparsing", "qualname": "Word.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.WordEnd", "modulename": "x4i.pyparsing", "qualname": "WordEnd", "type": "class", "doc": "<p>Matches if the current position is at the end of a Word, and is\nnot followed by any character in a given set of <code>wordChars</code>\n(default= <code>printables</code>). To emulate the <code>\b</code> behavior of\nregular expressions, use <code>WordEnd(alphanums)</code>. <code>WordEnd</code>\nwill also match at the end of the string being parsed, or at the end\nof a line.</p>\n", "bases": "_PositionToken"}, {"fullname": "x4i.pyparsing.WordEnd.__init__", "modulename": "x4i.pyparsing", "qualname": "WordEnd.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    wordChars='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'\n)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.WordEnd.parseImpl", "modulename": "x4i.pyparsing", "qualname": "WordEnd.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.WordStart", "modulename": "x4i.pyparsing", "qualname": "WordStart", "type": "class", "doc": "<p>Matches if the current position is at the beginning of a Word,\nand is not preceded by any character in a given set of\n<code>wordChars</code> (default= <code>printables</code>). To emulate the\n<code>\b</code> behavior of regular expressions, use\n<code>WordStart(alphanums)</code>. <code>WordStart</code> will also match at\nthe beginning of the string being parsed, or at the beginning of\na line.</p>\n", "bases": "_PositionToken"}, {"fullname": "x4i.pyparsing.WordStart.__init__", "modulename": "x4i.pyparsing", "qualname": "WordStart.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    wordChars='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'\n)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.WordStart.parseImpl", "modulename": "x4i.pyparsing", "qualname": "WordStart.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ZeroOrMore", "modulename": "x4i.pyparsing", "qualname": "ZeroOrMore", "type": "class", "doc": "<p>Optional repetition of zero or more of the given expression.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>expr - expression that must match zero or more times</li>\n<li>stopOn - (default= <code>None</code>) - expression for a terminating sentinel\n  (only required if the sentinel would ordinarily match the repetition\n  expression)</li>\n</ul>\n\n<p>Example: similar to <code>OneOrMore</code></p>\n", "bases": "_MultipleMatch"}, {"fullname": "x4i.pyparsing.ZeroOrMore.__init__", "modulename": "x4i.pyparsing", "qualname": "ZeroOrMore.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, expr, stopOn=None)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ZeroOrMore.parseImpl", "modulename": "x4i.pyparsing", "qualname": "ZeroOrMore.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.Char", "modulename": "x4i.pyparsing", "qualname": "Char", "type": "class", "doc": "<p>A short-cut class for defining <code>Word(characters, exact=1)</code>,\nwhen defining a match of any single character in a string of\ncharacters.</p>\n", "bases": "Word"}, {"fullname": "x4i.pyparsing.Char.__init__", "modulename": "x4i.pyparsing", "qualname": "Char.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, charset)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.alphanums", "modulename": "x4i.pyparsing", "qualname": "alphanums", "type": "variable", "doc": "<p></p>\n", "default_value": " = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'"}, {"fullname": "x4i.pyparsing.alphas", "modulename": "x4i.pyparsing", "qualname": "alphas", "type": "variable", "doc": "<p></p>\n", "default_value": " = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'"}, {"fullname": "x4i.pyparsing.alphas8bit", "modulename": "x4i.pyparsing", "qualname": "alphas8bit", "type": "variable", "doc": "<p></p>\n", "default_value": " = '\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff'"}, {"fullname": "x4i.pyparsing.anyCloseTag", "modulename": "x4i.pyparsing", "qualname": "anyCloseTag", "type": "variable", "doc": "<p></p>\n", "default_value": " = </any tag>"}, {"fullname": "x4i.pyparsing.anyOpenTag", "modulename": "x4i.pyparsing", "qualname": "anyOpenTag", "type": "variable", "doc": "<p></p>\n", "default_value": " = <any tag>"}, {"fullname": "x4i.pyparsing.cStyleComment", "modulename": "x4i.pyparsing", "qualname": "cStyleComment", "type": "variable", "doc": "<p>Comment of the form <code>/* ... */</code></p>\n", "default_value": " = C style comment"}, {"fullname": "x4i.pyparsing.col", "modulename": "x4i.pyparsing", "qualname": "col", "type": "function", "doc": "<p>Returns current column within a string, counting newlines as line separators.\nThe first column is number 1.</p>\n\n<p>Note: the default parsing behavior is to expand tabs in the input string\nbefore starting the parsing process.  See\n<code>ParserElement.parseString</code> for more\ninformation on parsing strings containing <code>&lt;TAB&gt;</code> s, and suggested\nmethods to maintain a consistent view of the parsed string, the parse\nlocation, and line and column positions within the parsed string.</p>\n", "signature": "(loc, strg)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.commaSeparatedList", "modulename": "x4i.pyparsing", "qualname": "commaSeparatedList", "type": "variable", "doc": "<p>(Deprecated) Predefined expression of 1 or more printable words or\nquoted strings, separated by commas.</p>\n\n<p>This expression is deprecated in favor of <code>pyparsing_common.comma_separated_list</code>.</p>\n", "default_value": " = commaSeparatedList"}, {"fullname": "x4i.pyparsing.commonHTMLEntity", "modulename": "x4i.pyparsing", "qualname": "commonHTMLEntity", "type": "variable", "doc": "<p></p>\n", "default_value": " = common HTML entity"}, {"fullname": "x4i.pyparsing.countedArray", "modulename": "x4i.pyparsing", "qualname": "countedArray", "type": "function", "doc": "<p>Helper to define a counted list of expressions.</p>\n\n<p>This helper defines a pattern of the form::</p>\n\n<pre><code>integer expr expr expr...\n</code></pre>\n\n<p>where the leading integer tells how many expr expressions follow.\nThe matched tokens returns the array of expr tokens as a list - the\nleading count token is suppressed.</p>\n\n<p>If <code>intExpr</code> is specified, it should be a pyparsing expression\nthat produces an integer value.</p>\n\n<p>Example::</p>\n\n<pre><code>countedArray(Word(alphas)).parseString('2 ab cd ef')  # -&gt; ['ab', 'cd']\n\n# in this parser, the leading integer value is given in binary,\n# '10' indicating that 2 values are in the array\nbinaryConstant = Word('01').setParseAction(lambda t: int(t[0], 2))\ncountedArray(Word(alphas), intExpr=binaryConstant).parseString('10 ab cd ef')  # -&gt; ['ab', 'cd']\n</code></pre>\n", "signature": "(expr, intExpr=None)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.cppStyleComment", "modulename": "x4i.pyparsing", "qualname": "cppStyleComment", "type": "variable", "doc": "<p>Comment of either form <code>cStyleComment</code> or <code>dblSlashComment</code></p>\n", "default_value": " = C++ style comment"}, {"fullname": "x4i.pyparsing.dblQuotedString", "modulename": "x4i.pyparsing", "qualname": "dblQuotedString", "type": "variable", "doc": "<p></p>\n", "default_value": " = string enclosed in double quotes"}, {"fullname": "x4i.pyparsing.dblSlashComment", "modulename": "x4i.pyparsing", "qualname": "dblSlashComment", "type": "variable", "doc": "<p>Comment of the form <code>// ... (to end of line)</code></p>\n", "default_value": " = // comment"}, {"fullname": "x4i.pyparsing.delimitedList", "modulename": "x4i.pyparsing", "qualname": "delimitedList", "type": "function", "doc": "<p>Helper to define a delimited list of expressions - the delimiter\ndefaults to ','. By default, the list elements and delimiters can\nhave intervening whitespace, and comments, but this can be\noverridden by passing <code>combine=True</code> in the constructor. If\n<code>combine</code> is set to <code>True</code>, the matching tokens are\nreturned as a single token string, with the delimiters included;\notherwise, the matching tokens are returned as a list of tokens,\nwith the delimiters suppressed.</p>\n\n<p>Example::</p>\n\n<pre><code>delimitedList(Word(alphas)).parseString(\"aa,bb,cc\") # -&gt; ['aa', 'bb', 'cc']\ndelimitedList(Word(hexnums), delim=':', combine=True).parseString(\"AA:BB:CC:DD:EE\") # -&gt; ['AA:BB:CC:DD:EE']\n</code></pre>\n", "signature": "(expr, delim=',', combine=False)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.dictOf", "modulename": "x4i.pyparsing", "qualname": "dictOf", "type": "function", "doc": "<p>Helper to easily and clearly define a dictionary by specifying\nthe respective patterns for the key and value.  Takes care of\ndefining the <code>Dict</code>, <code>ZeroOrMore</code>, and\n<code>Group</code> tokens in the proper order.  The key pattern\ncan include delimiting markers or punctuation, as long as they are\nsuppressed, thereby leaving the significant key text.  The value\npattern can include named results, so that the <code>Dict</code> results\ncan include named token fields.</p>\n\n<p>Example::</p>\n\n<pre><code>text = \"shape: SQUARE posn: upper left color: light blue texture: burlap\"\nattr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))\nprint(OneOrMore(attr_expr).parseString(text).dump())\n\nattr_label = label\nattr_value = Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join)\n\n# similar to Dict, but simpler call format\nresult = dictOf(attr_label, attr_value).parseString(text)\nprint(result.dump())\nprint(result['shape'])\nprint(result.shape)  # object attribute access works too\nprint(result.asDict())\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>[['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]\n- color: light blue\n- posn: upper left\n- shape: SQUARE\n- texture: burlap\nSQUARE\nSQUARE\n{'color': 'light blue', 'shape': 'SQUARE', 'posn': 'upper left', 'texture': 'burlap'}\n</code></pre>\n", "signature": "(key, value)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.downcaseTokens", "modulename": "x4i.pyparsing", "qualname": "downcaseTokens", "type": "function", "doc": "<p>(Deprecated) Helper parse action to convert tokens to lower case.\nDeprecated in favor of <code>pyparsing_common.downcaseTokens</code></p>\n", "signature": "(s, l, t)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.empty", "modulename": "x4i.pyparsing", "qualname": "empty", "type": "variable", "doc": "<p></p>\n", "default_value": " = empty"}, {"fullname": "x4i.pyparsing.hexnums", "modulename": "x4i.pyparsing", "qualname": "hexnums", "type": "variable", "doc": "<p></p>\n", "default_value": " = '0123456789ABCDEFabcdef'"}, {"fullname": "x4i.pyparsing.htmlComment", "modulename": "x4i.pyparsing", "qualname": "htmlComment", "type": "variable", "doc": "<p>Comment of the form <code>&lt;!-- ... --&gt;</code></p>\n", "default_value": " = HTML comment"}, {"fullname": "x4i.pyparsing.javaStyleComment", "modulename": "x4i.pyparsing", "qualname": "javaStyleComment", "type": "variable", "doc": "<p>Same as <code>cppStyleComment</code></p>\n", "default_value": " = C++ style comment"}, {"fullname": "x4i.pyparsing.line", "modulename": "x4i.pyparsing", "qualname": "line", "type": "function", "doc": "<p>Returns the line of text containing loc within a string, counting newlines as line separators.</p>\n", "signature": "(loc, strg)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.lineEnd", "modulename": "x4i.pyparsing", "qualname": "lineEnd", "type": "variable", "doc": "<p></p>\n", "default_value": " = lineEnd"}, {"fullname": "x4i.pyparsing.lineStart", "modulename": "x4i.pyparsing", "qualname": "lineStart", "type": "variable", "doc": "<p></p>\n", "default_value": " = lineStart"}, {"fullname": "x4i.pyparsing.lineno", "modulename": "x4i.pyparsing", "qualname": "lineno", "type": "function", "doc": "<p>Returns current line number within a string, counting newlines as line separators.\nThe first line is number 1.</p>\n\n<p>Note - the default parsing behavior is to expand tabs in the input string\nbefore starting the parsing process.  See <code>ParserElement.parseString</code>\nfor more information on parsing strings containing <code>&lt;TAB&gt;</code> s, and\nsuggested methods to maintain a consistent view of the parsed string, the\nparse location, and line and column positions within the parsed string.</p>\n", "signature": "(loc, strg)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.makeHTMLTags", "modulename": "x4i.pyparsing", "qualname": "makeHTMLTags", "type": "function", "doc": "<p>Helper to construct opening and closing tag expressions for HTML,\ngiven a tag name. Matches tags in either upper or lower case,\nattributes with namespaces and with quoted or unquoted values.</p>\n\n<p>Example::</p>\n\n<pre><code>text = '&lt;td&gt;More info at the &lt;a href=\"https://github.com/pyparsing/pyparsing/wiki\"&gt;pyparsing&lt;/a&gt; wiki page&lt;/td&gt;'\n# makeHTMLTags returns pyparsing expressions for the opening and\n# closing tags as a 2-tuple\na,a_end = makeHTMLTags(\"A\")\nlink_expr = a + SkipTo(a_end)(\"link_text\") + a_end\n\nfor link in link_expr.searchString(text):\n    # attributes in the &lt;A&gt; tag (like \"href\" shown here) are\n    # also accessible as named results\n    print(link.link_text, '-&gt;', link.href)\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>pyparsing -&gt; https://github.com/pyparsing/pyparsing/wiki\n</code></pre>\n", "signature": "(tagStr)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.makeXMLTags", "modulename": "x4i.pyparsing", "qualname": "makeXMLTags", "type": "function", "doc": "<p>Helper to construct opening and closing tag expressions for XML,\ngiven a tag name. Matches tags only in the given upper/lower case.</p>\n\n<p>Example: similar to <code>makeHTMLTags</code></p>\n", "signature": "(tagStr)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.matchOnlyAtCol", "modulename": "x4i.pyparsing", "qualname": "matchOnlyAtCol", "type": "function", "doc": "<p>Helper method for defining parse actions that require matching at\na specific column in the input text.</p>\n", "signature": "(n)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.matchPreviousExpr", "modulename": "x4i.pyparsing", "qualname": "matchPreviousExpr", "type": "function", "doc": "<p>Helper to define an expression that is indirectly defined from\nthe tokens matched in a previous expression, that is, it looks for\na 'repeat' of a previous expression.  For example::</p>\n\n<pre><code>first = Word(nums)\nsecond = matchPreviousExpr(first)\nmatchExpr = first + \":\" + second\n</code></pre>\n\n<p>will match <code>\"1:1\"</code>, but not <code>\"1:2\"</code>.  Because this\nmatches by expressions, will <em>not</em> match the leading <code>\"1:1\"</code>\nin <code>\"1:10\"</code>; the expressions are evaluated first, and then\ncompared, so <code>\"1\"</code> is compared with <code>\"10\"</code>. Do <em>not</em> use\nwith packrat parsing enabled.</p>\n", "signature": "(expr)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.matchPreviousLiteral", "modulename": "x4i.pyparsing", "qualname": "matchPreviousLiteral", "type": "function", "doc": "<p>Helper to define an expression that is indirectly defined from\nthe tokens matched in a previous expression, that is, it looks for\na 'repeat' of a previous expression.  For example::</p>\n\n<pre><code>first = Word(nums)\nsecond = matchPreviousLiteral(first)\nmatchExpr = first + \":\" + second\n</code></pre>\n\n<p>will match <code>\"1:1\"</code>, but not <code>\"1:2\"</code>.  Because this\nmatches a previous literal, will also match the leading\n<code>\"1:1\"</code> in <code>\"1:10\"</code>. If this is not desired, use\n<code>matchPreviousExpr</code>. Do <em>not</em> use with packrat parsing\nenabled.</p>\n", "signature": "(expr)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.nestedExpr", "modulename": "x4i.pyparsing", "qualname": "nestedExpr", "type": "function", "doc": "<p>Helper method for defining nested lists enclosed in opening and\nclosing delimiters (\"(\" and \")\" are the default).</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>opener - opening character for a nested list\n(default= <code>\"(\"</code>); can also be a pyparsing expression</li>\n<li>closer - closing character for a nested list\n(default= <code>\")\"</code>); can also be a pyparsing expression</li>\n<li>content - expression for items within the nested lists\n(default= <code>None</code>)</li>\n<li>ignoreExpr - expression for ignoring opening and closing\ndelimiters (default= <code>quotedString</code>)</li>\n</ul>\n\n<p>If an expression is not provided for the content argument, the\nnested expression will capture all whitespace-delimited content\nbetween delimiters as a list of separate values.</p>\n\n<p>Use the <code>ignoreExpr</code> argument to define expressions that may\ncontain opening or closing characters that should not be treated as\nopening or closing characters for nesting, such as quotedString or\na comment expression.  Specify multiple expressions using an\n<code>Or</code> or <code>MatchFirst</code>. The default is\n<code>quotedString</code>, but if no expressions are to be ignored, then\npass <code>None</code> for this argument.</p>\n\n<p>Example::</p>\n\n<pre><code>data_type = oneOf(\"void int short long char float double\")\ndecl_data_type = Combine(data_type + Optional(Word('*')))\nident = Word(alphas+'_', alphanums+'_')\nnumber = pyparsing_common.number\narg = Group(decl_data_type + ident)\nLPAR,RPAR = map(Suppress, \"()\")\n\ncode_body = nestedExpr('{', '}', ignoreExpr=(quotedString | cStyleComment))\n\nc_function = (decl_data_type(\"type\")\n              + ident(\"name\")\n              + LPAR + Optional(delimitedList(arg), [])(\"args\") + RPAR\n              + code_body(\"body\"))\nc_function.ignore(cStyleComment)\n\nsource_code = '''\n    int is_odd(int x) {\n        return (x%2);\n    }\n\n    int dec_to_hex(char hchar) {\n        if (hchar &gt;= '0' &amp;&amp; hchar &lt;= '9') {\n            return (ord(hchar)-ord('0'));\n        } else {\n            return (10+ord(hchar)-ord('A'));\n        }\n    }\n'''\nfor func in c_function.searchString(source_code):\n    print(\"%(name)s (%(type)s) args: %(args)s\" % func)\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>is_odd (int) args: [['int', 'x']]\ndec_to_hex (int) args: [['char', 'hchar']]\n</code></pre>\n", "signature": "(\n    opener='(',\n    closer=')',\n    content=None,\n    ignoreExpr=quotedString using single or double quotes\n)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.nullDebugAction", "modulename": "x4i.pyparsing", "qualname": "nullDebugAction", "type": "function", "doc": "<p>'Do-nothing' debug action, to suppress debugging output during parsing.</p>\n", "signature": "(*args)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.nums", "modulename": "x4i.pyparsing", "qualname": "nums", "type": "variable", "doc": "<p></p>\n", "default_value": " = '0123456789'"}, {"fullname": "x4i.pyparsing.oneOf", "modulename": "x4i.pyparsing", "qualname": "oneOf", "type": "function", "doc": "<p>Helper to quickly define a set of alternative Literals, and makes\nsure to do longest-first testing when there is a conflict,\nregardless of the input order, but returns\na <code>MatchFirst</code> for best performance.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>strs - a string of space-delimited literals, or a collection of\nstring literals</li>\n<li>caseless - (default= <code>False</code>) - treat all literals as\ncaseless</li>\n<li>useRegex - (default= <code>True</code>) - as an optimization, will\ngenerate a Regex object; otherwise, will generate\na <code>MatchFirst</code> object (if <code>caseless=True</code>, or if\ncreating a <code>Regex</code> raises an exception)</li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code>comp_oper = oneOf(\"&lt; = &gt; &lt;= &gt;= !=\")\nvar = Word(alphas)\nnumber = Word(nums)\nterm = var | number\ncomparison_expr = term + comp_oper + term\nprint(comparison_expr.searchString(\"B = 12  AA=23 B&lt;=AA AA&gt;12\"))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>[['B', '=', '12'], ['AA', '=', '23'], ['B', '&lt;=', 'AA'], ['AA', '&gt;', '12']]\n</code></pre>\n", "signature": "(strs, caseless=False, useRegex=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.opAssoc", "modulename": "x4i.pyparsing", "qualname": "opAssoc", "type": "variable", "doc": "<p></p>\n", "default_value": " = namespace(LEFT=<object object>, RIGHT=<object object>)"}, {"fullname": "x4i.pyparsing.operatorPrecedence", "modulename": "x4i.pyparsing", "qualname": "operatorPrecedence", "type": "function", "doc": "<p>(Deprecated) Former name of <code>infixNotation</code>, will be\ndropped in a future release.</p>\n", "signature": "(baseExpr, opList, lpar=Suppress:(\"(\"), rpar=Suppress:(\")\"))", "funcdef": "def"}, {"fullname": "x4i.pyparsing.printables", "modulename": "x4i.pyparsing", "qualname": "printables", "type": "variable", "doc": "<p></p>\n", "default_value": " = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'"}, {"fullname": "x4i.pyparsing.punc8bit", "modulename": "x4i.pyparsing", "qualname": "punc8bit", "type": "variable", "doc": "<p></p>\n", "default_value": " = '\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\\xad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00d7\u00f7'"}, {"fullname": "x4i.pyparsing.pythonStyleComment", "modulename": "x4i.pyparsing", "qualname": "pythonStyleComment", "type": "variable", "doc": "<p>Comment of the form <code># ... (to end of line)</code></p>\n", "default_value": " = Python style comment"}, {"fullname": "x4i.pyparsing.quotedString", "modulename": "x4i.pyparsing", "qualname": "quotedString", "type": "variable", "doc": "<p></p>\n", "default_value": " = quotedString using single or double quotes"}, {"fullname": "x4i.pyparsing.removeQuotes", "modulename": "x4i.pyparsing", "qualname": "removeQuotes", "type": "function", "doc": "<p>Helper parse action for removing quotation marks from parsed\nquoted strings.</p>\n\n<p>Example::</p>\n\n<pre><code># by default, quotation marks are included in parsed results\nquotedString.parseString(\"'Now is the Winter of our Discontent'\") # -&gt; [\"'Now is the Winter of our Discontent'\"]\n\n# use removeQuotes to strip quotation marks from parsed results\nquotedString.setParseAction(removeQuotes)\nquotedString.parseString(\"'Now is the Winter of our Discontent'\") # -&gt; [\"Now is the Winter of our Discontent\"]\n</code></pre>\n", "signature": "(s, l, t)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.replaceHTMLEntity", "modulename": "x4i.pyparsing", "qualname": "replaceHTMLEntity", "type": "function", "doc": "<p>Helper parser action to replace common HTML entities with their special characters</p>\n", "signature": "(t)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.replaceWith", "modulename": "x4i.pyparsing", "qualname": "replaceWith", "type": "function", "doc": "<p>Helper method for common parse actions that simply return\na literal value.  Especially useful when used with\n<code>transformString&lt;ParserElement.transformString&gt;</code> ().</p>\n\n<p>Example::</p>\n\n<pre><code>num = Word(nums).setParseAction(lambda toks: int(toks[0]))\nna = oneOf(\"N/A NA\").setParseAction(replaceWith(math.nan))\nterm = na | num\n\nOneOrMore(term).parseString(\"324 234 N/A 234\") # -&gt; [324, 234, nan, 234]\n</code></pre>\n", "signature": "(replStr)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.restOfLine", "modulename": "x4i.pyparsing", "qualname": "restOfLine", "type": "variable", "doc": "<p></p>\n", "default_value": " = rest of line"}, {"fullname": "x4i.pyparsing.sglQuotedString", "modulename": "x4i.pyparsing", "qualname": "sglQuotedString", "type": "variable", "doc": "<p></p>\n", "default_value": " = string enclosed in single quotes"}, {"fullname": "x4i.pyparsing.srange", "modulename": "x4i.pyparsing", "qualname": "srange", "type": "function", "doc": "<p>Helper to easily define string ranges for use in Word\nconstruction. Borrows syntax from regexp '[]' string range\ndefinitions::</p>\n\n<pre><code>srange(\"[0-9]\")   -&gt; \"0123456789\"\nsrange(\"[a-z]\")   -&gt; \"abcdefghijklmnopqrstuvwxyz\"\nsrange(\"[a-z$_]\") -&gt; \"abcdefghijklmnopqrstuvwxyz$_\"\n</code></pre>\n\n<p>The input string must be enclosed in []'s, and the returned string\nis the expanded character set joined into a single string. The\nvalues enclosed in the []'s may be:</p>\n\n<ul>\n<li>a single character</li>\n<li>an escaped character with a leading backslash (such as <code>\\-</code>\nor <code>\\]</code>)</li>\n<li>an escaped hex character with a leading <code>'\\x'</code>\n(<code>\\x21</code>, which is a <code>'!'</code> character) (<code>\\0x##</code>\nis also supported for backwards compatibility)</li>\n<li>an escaped octal character with a leading <code>'\\0'</code>\n(<code>\\041</code>, which is a <code>'!'</code> character)</li>\n<li>a range of any of the above, separated by a dash (<code>'a-z'</code>,\netc.)</li>\n<li>any combination of the above (<code>'aeiouy'</code>,\n<code>'a-zA-Z0-9_$'</code>, etc.)</li>\n</ul>\n", "signature": "(s)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.stringEnd", "modulename": "x4i.pyparsing", "qualname": "stringEnd", "type": "variable", "doc": "<p></p>\n", "default_value": " = stringEnd"}, {"fullname": "x4i.pyparsing.stringStart", "modulename": "x4i.pyparsing", "qualname": "stringStart", "type": "variable", "doc": "<p></p>\n", "default_value": " = stringStart"}, {"fullname": "x4i.pyparsing.traceParseAction", "modulename": "x4i.pyparsing", "qualname": "traceParseAction", "type": "function", "doc": "<p>Decorator for debugging parse actions.</p>\n\n<p>When the parse action is called, this decorator will print\n<code>\"&gt;&gt; entering method-name(line:&lt;current_source_line&gt;, &lt;parse_location&gt;, &lt;matched_tokens&gt;)\"</code>.\nWhen the parse action completes, the decorator will print\n<code>\"&lt;&lt;\"</code> followed by the returned value, or any exception that the parse action raised.</p>\n\n<p>Example::</p>\n\n<pre><code>wd = Word(alphas)\n\n@traceParseAction\ndef remove_duplicate_chars(tokens):\n    return ''.join(sorted(set(''.join(tokens))))\n\nwds = OneOrMore(wd).setParseAction(remove_duplicate_chars)\nprint(wds.parseString(\"slkdjs sld sldd sdlf sdljf\"))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>&gt;&gt;entering remove_duplicate_chars(line: 'slkdjs sld sldd sdlf sdljf', 0, (['slkdjs', 'sld', 'sldd', 'sdlf', 'sdljf'], {}))\n&lt;&lt;leaving remove_duplicate_chars (ret: 'dfjkls')\n['dfjkls']\n</code></pre>\n", "signature": "(f)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.unicodeString", "modulename": "x4i.pyparsing", "qualname": "unicodeString", "type": "variable", "doc": "<p></p>\n", "default_value": " = unicode string literal"}, {"fullname": "x4i.pyparsing.upcaseTokens", "modulename": "x4i.pyparsing", "qualname": "upcaseTokens", "type": "function", "doc": "<p>(Deprecated) Helper parse action to convert tokens to upper case.\nDeprecated in favor of <code>pyparsing_common.upcaseTokens</code></p>\n", "signature": "(s, l, t)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.withAttribute", "modulename": "x4i.pyparsing", "qualname": "withAttribute", "type": "function", "doc": "<p>Helper to create a validating parse action to be used with start\ntags created with <code>makeXMLTags</code> or\n<code>makeHTMLTags</code>. Use <code>withAttribute</code> to qualify\na starting tag with a required attribute value, to avoid false\nmatches on common tags such as <code>&lt;TD&gt;</code> or <code>&lt;DIV&gt;</code>.</p>\n\n<p>Call <code>withAttribute</code> with a series of attribute names and\nvalues. Specify the list of filter attributes names and values as:</p>\n\n<ul>\n<li>keyword arguments, as in <code>(align=\"right\")</code>, or</li>\n<li>as an explicit dict with <code>**</code> operator, when an attribute\nname is also a Python reserved word, as in <code>**{\"class\":\"Customer\", \"align\":\"right\"}</code></li>\n<li>a list of name-value tuples, as in <code>((\"ns1:class\", \"Customer\"), (\"ns2:align\",\"right\"))</code></li>\n</ul>\n\n<p>For attribute names with a namespace prefix, you must use the second\nform.  Attribute names are matched insensitive to upper/lower case.</p>\n\n<p>If just testing for <code>class</code> (with or without a namespace), use\n<code>withClass</code>.</p>\n\n<p>To verify that the attribute exists, but without specifying a value,\npass <code>withAttribute.ANY_VALUE</code> as the value.</p>\n\n<p>Example::</p>\n\n<pre><code>html = '''\n    &lt;div&gt;\n    Some text\n    &lt;div type=\"grid\"&gt;1 4 0 1 0&lt;/div&gt;\n    &lt;div type=\"graph\"&gt;1,3 2,3 1,1&lt;/div&gt;\n    &lt;div&gt;this has no type&lt;/div&gt;\n    &lt;/div&gt;\n\n'''\ndiv,div_end = makeHTMLTags(\"div\")\n\n# only match div tag having a type attribute with value \"grid\"\ndiv_grid = div().setParseAction(withAttribute(type=\"grid\"))\ngrid_expr = div_grid + SkipTo(div | div_end)(\"body\")\nfor grid_header in grid_expr.searchString(html):\n    print(grid_header.body)\n\n# construct a match with any div tag having a type attribute, regardless of the value\ndiv_any_type = div().setParseAction(withAttribute(type=withAttribute.ANY_VALUE))\ndiv_expr = div_any_type + SkipTo(div | div_end)(\"body\")\nfor div_header in div_expr.searchString(html):\n    print(div_header.body)\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>1 4 0 1 0\n\n1 4 0 1 0\n1,3 2,3 1,1\n</code></pre>\n", "signature": "(*args, **attrDict)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.indentedBlock", "modulename": "x4i.pyparsing", "qualname": "indentedBlock", "type": "function", "doc": "<p>Helper method for defining space-delimited indentation blocks,\nsuch as those used to define block statements in Python source code.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>blockStatementExpr - expression defining syntax of statement that\nis repeated within the indented block</li>\n<li>indentStack - list created by caller to manage indentation stack\n(multiple statementWithIndentedBlock expressions within a single\ngrammar should share a common indentStack)</li>\n<li>indent - boolean indicating whether block must be indented beyond\nthe the current level; set to False for block of left-most\nstatements (default= <code>True</code>)</li>\n</ul>\n\n<p>A valid block must contain at least one <code>blockStatement</code>.</p>\n\n<p>Example::</p>\n\n<pre><code>data = '''\ndef A(z):\n  A1\n  B = 100\n  G = A2\n  A2\n  A3\nB\ndef BB(a,b,c):\n  BB1\n  def BBA():\n    bba1\n    bba2\n    bba3\nC\nD\ndef spam(x,y):\n     def eggs(z):\n         pass\n'''\n\n\nindentStack = [1]\nstmt = Forward()\n\nidentifier = Word(alphas, alphanums)\nfuncDecl = (\"def\" + identifier + Group( \"(\" + Optional( delimitedList(identifier) ) + \")\" ) + \":\")\nfunc_body = indentedBlock(stmt, indentStack)\nfuncDef = Group( funcDecl + func_body )\n\nrvalue = Forward()\nfuncCall = Group(identifier + \"(\" + Optional(delimitedList(rvalue)) + \")\")\nrvalue &lt;&lt; (funcCall | identifier | Word(nums))\nassignment = Group(identifier + \"=\" + rvalue)\nstmt &lt;&lt; ( funcDef | assignment | identifier )\n\nmodule_body = OneOrMore(stmt)\n\nparseTree = module_body.parseString(data)\nparseTree.pprint()\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>[['def',\n  'A',\n  ['(', 'z', ')'],\n  ':',\n  [['A1'], [['B', '=', '100']], [['G', '=', 'A2']], ['A2'], ['A3']]],\n 'B',\n ['def',\n  'BB',\n  ['(', 'a', 'b', 'c', ')'],\n  ':',\n  [['BB1'], [['def', 'BBA', ['(', ')'], ':', [['bba1'], ['bba2'], ['bba3']]]]]],\n 'C',\n 'D',\n ['def',\n  'spam',\n  ['(', 'x', 'y', ')'],\n  ':',\n  [[['def', 'eggs', ['(', 'z', ')'], ':', [['pass']]]]]]]\n</code></pre>\n", "signature": "(blockStatementExpr, indentStack, indent=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.originalTextFor", "modulename": "x4i.pyparsing", "qualname": "originalTextFor", "type": "function", "doc": "<p>Helper to return the original, untokenized text for a given\nexpression.  Useful to restore the parsed fields of an HTML start\ntag into the raw tag text itself, or to revert separate tokens with\nintervening whitespace back to the original matching input text. By\ndefault, returns astring containing the original parsed text.</p>\n\n<p>If the optional <code>asString</code> argument is passed as\n<code>False</code>, then the return value is\na <code>ParseResults</code> containing any results names that\nwere originally matched, and a single token containing the original\nmatched text from the input string.  So if the expression passed to\n<code>originalTextFor</code> contains expressions with defined\nresults names, you must set <code>asString</code> to <code>False</code> if you\nwant to preserve those results name values.</p>\n\n<p>Example::</p>\n\n<pre><code>src = \"this is test &lt;b&gt; bold &lt;i&gt;text&lt;/i&gt; &lt;/b&gt; normal text \"\nfor tag in (\"b\",\"i\"):\n    opener,closer = makeHTMLTags(tag)\n    patt = originalTextFor(opener + SkipTo(closer) + closer)\n    print(patt.searchString(src)[0])\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>['&lt;b&gt; bold &lt;i&gt;text&lt;/i&gt; &lt;/b&gt;']\n['&lt;i&gt;text&lt;/i&gt;']\n</code></pre>\n", "signature": "(expr, asString=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.ungroup", "modulename": "x4i.pyparsing", "qualname": "ungroup", "type": "function", "doc": "<p>Helper to undo pyparsing's default grouping of And expressions,\neven if all but one are non-empty.</p>\n", "signature": "(expr)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.infixNotation", "modulename": "x4i.pyparsing", "qualname": "infixNotation", "type": "function", "doc": "<p>Helper method for constructing grammars of expressions made up of\noperators working in a precedence hierarchy.  Operators may be unary\nor binary, left- or right-associative.  Parse actions can also be\nattached to operator expressions. The generated parser will also\nrecognize the use of parentheses to override operator precedences\n(see example below).</p>\n\n<p>Note: if you define a deep operator list, you may see performance\nissues when using infixNotation. See\n<code>ParserElement.enablePackrat</code> for a mechanism to potentially\nimprove your parser performance.</p>\n\n<p>Parameters:</p>\n\n<ul>\n<li>baseExpr - expression representing the most basic element for the\nnested</li>\n<li>opList - list of tuples, one for each operator precedence level\nin the expression grammar; each tuple is of the form <code>(opExpr,\nnumTerms, rightLeftAssoc, parseAction)</code>, where:</li>\n</ul>\n\n<ul>\n<li>opExpr is the pyparsing expression for the operator; may also\n be a string, which will be converted to a Literal; if numTerms\n is 3, opExpr is a tuple of two expressions, for the two\n operators separating the 3 terms</li>\n<li>numTerms is the number of terms for this operator (must be 1,\n 2, or 3)</li>\n<li>rightLeftAssoc is the indicator whether the operator is right\n or left associative, using the pyparsing-defined constants\n <code>opAssoc.RIGHT</code> and <code>opAssoc.LEFT</code>.</li>\n<li>parseAction is the parse action to be associated with\n expressions matching this operator expression (the parse action\n tuple member may be omitted); if the parse action is passed\n a tuple or list of functions, this is equivalent to calling\n <code>setParseAction(*fn)</code>\n (<code>ParserElement.setParseAction</code>)\n<ul>\n<li>lpar - expression for matching left-parentheses\n(default= <code>Suppress('(')</code>)</li>\n<li>rpar - expression for matching right-parentheses\n(default= <code>Suppress(')')</code>)</li>\n</ul></li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code># simple example of four-function arithmetic with ints and\n# variable names\ninteger = pyparsing_common.signed_integer\nvarname = pyparsing_common.identifier\n\narith_expr = infixNotation(integer | varname,\n    [\n    ('-', 1, opAssoc.RIGHT),\n    (oneOf('* /'), 2, opAssoc.LEFT),\n    (oneOf('+ -'), 2, opAssoc.LEFT),\n    ])\n\narith_expr.runTests('''\n    5+3*6\n    (5+3)*6\n    -2--11\n    ''', fullDump=False)\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>5+3*6\n[[5, '+', [3, '*', 6]]]\n\n(5+3)*6\n[[[5, '+', 3], '*', 6]]\n\n-2--11\n[[['-', 2], '-', ['-', 11]]]\n</code></pre>\n", "signature": "(baseExpr, opList, lpar=Suppress:(\"(\"), rpar=Suppress:(\")\"))", "funcdef": "def"}, {"fullname": "x4i.pyparsing.locatedExpr", "modulename": "x4i.pyparsing", "qualname": "locatedExpr", "type": "function", "doc": "<p>Helper to decorate a returned token with its starting and ending\nlocations in the input string.</p>\n\n<p>This helper adds the following results names:</p>\n\n<ul>\n<li>locn_start = location where matched expression begins</li>\n<li>locn_end = location where matched expression ends</li>\n<li>value = the actual parsed results</li>\n</ul>\n\n<p>Be careful if the input text contains <code>&lt;TAB&gt;</code> characters, you\nmay want to call <code>ParserElement.parseWithTabs</code></p>\n\n<p>Example::</p>\n\n<pre><code>wd = Word(alphas)\nfor match in locatedExpr(wd).searchString(\"ljsdf123lksdjjf123lkkjj1222\"):\n    print(match)\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>[[0, 'ljsdf', 5]]\n[[8, 'lksdjjf', 15]]\n[[18, 'lkkjj', 23]]\n</code></pre>\n", "signature": "(expr)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.withClass", "modulename": "x4i.pyparsing", "qualname": "withClass", "type": "function", "doc": "<p>Simplified version of <code>withAttribute</code> when\nmatching on a div class - made difficult because <code>class</code> is\na reserved word in Python.</p>\n\n<p>Example::</p>\n\n<pre><code>html = '''\n    &lt;div&gt;\n    Some text\n    &lt;div class=\"grid\"&gt;1 4 0 1 0&lt;/div&gt;\n    &lt;div class=\"graph\"&gt;1,3 2,3 1,1&lt;/div&gt;\n    &lt;div&gt;this &amp;lt;div&amp;gt; has no class&lt;/div&gt;\n    &lt;/div&gt;\n\n'''\ndiv,div_end = makeHTMLTags(\"div\")\ndiv_grid = div().setParseAction(withClass(\"grid\"))\n\ngrid_expr = div_grid + SkipTo(div | div_end)(\"body\")\nfor grid_header in grid_expr.searchString(html):\n    print(grid_header.body)\n\ndiv_any_type = div().setParseAction(withClass(withAttribute.ANY_VALUE))\ndiv_expr = div_any_type + SkipTo(div | div_end)(\"body\")\nfor div_header in div_expr.searchString(html):\n    print(div_header.body)\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>1 4 0 1 0\n\n1 4 0 1 0\n1,3 2,3 1,1\n</code></pre>\n", "signature": "(classname, namespace='')", "funcdef": "def"}, {"fullname": "x4i.pyparsing.CloseMatch", "modulename": "x4i.pyparsing", "qualname": "CloseMatch", "type": "class", "doc": "<p>A variation on <code>Literal</code> which matches \"close\" matches,\nthat is, strings with at most 'n' mismatching characters.\n<code>CloseMatch</code> takes parameters:</p>\n\n<ul>\n<li><code>match_string</code> - string to be matched</li>\n<li><code>maxMismatches</code> - (<code>default=1</code>) maximum number of\nmismatches allowed to count as a match</li>\n</ul>\n\n<p>The results from a successful parse will contain the matched text\nfrom the input string and the following named results:</p>\n\n<ul>\n<li><code>mismatches</code> - a list of the positions within the\nmatch_string where mismatches were found</li>\n<li><code>original</code> - the original match_string used to compare\nagainst the input string</li>\n</ul>\n\n<p>If <code>mismatches</code> is an empty list, then the match was an exact\nmatch.</p>\n\n<p>Example::</p>\n\n<pre><code>patt = CloseMatch(\"ATCATCGAATGGA\")\npatt.parseString(\"ATCATCGAAXGGA\") # -&gt; (['ATCATCGAAXGGA'], {'mismatches': [[9]], 'original': ['ATCATCGAATGGA']})\npatt.parseString(\"ATCAXCGAAXGGA\") # -&gt; Exception: Expected 'ATCATCGAATGGA' (with up to 1 mismatches) (at char 0), (line:1, col:1)\n\n# exact match\npatt.parseString(\"ATCATCGAATGGA\") # -&gt; (['ATCATCGAATGGA'], {'mismatches': [[]], 'original': ['ATCATCGAATGGA']})\n\n# close match allowing up to 2 mismatches\npatt = CloseMatch(\"ATCATCGAATGGA\", maxMismatches=2)\npatt.parseString(\"ATCAXCGAAXGGA\") # -&gt; (['ATCAXCGAAXGGA'], {'mismatches': [[4, 9]], 'original': ['ATCATCGAATGGA']})\n</code></pre>\n", "bases": "Token"}, {"fullname": "x4i.pyparsing.CloseMatch.__init__", "modulename": "x4i.pyparsing", "qualname": "CloseMatch.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, match_string, maxMismatches=1)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.CloseMatch.parseImpl", "modulename": "x4i.pyparsing", "qualname": "CloseMatch.parseImpl", "type": "function", "doc": "<p></p>\n", "signature": "(self, instring, loc, doActions=True)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.tokenMap", "modulename": "x4i.pyparsing", "qualname": "tokenMap", "type": "function", "doc": "<p>Helper to define a parse action by mapping a function to all\nelements of a ParseResults list. If any additional args are passed,\nthey are forwarded to the given function as additional arguments\nafter the token, as in\n<code>hex_integer = Word(hexnums).setParseAction(tokenMap(int, 16))</code>,\nwhich will convert the parsed data to an integer using base 16.</p>\n\n<p>Example (compare the last to example in <code>ParserElement.transformString</code>::</p>\n\n<pre><code>hex_ints = OneOrMore(Word(hexnums)).setParseAction(tokenMap(int, 16))\nhex_ints.runTests('''\n    00 11 22 aa FF 0a 0d 1a\n    ''')\n\nupperword = Word(alphas).setParseAction(tokenMap(str.upper))\nOneOrMore(upperword).runTests('''\n    my kingdom for a horse\n    ''')\n\nwd = Word(alphas).setParseAction(tokenMap(str.title))\nOneOrMore(wd).setParseAction(' '.join).runTests('''\n    now is the winter of our discontent made glorious summer by this sun of york\n    ''')\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>00 11 22 aa FF 0a 0d 1a\n[0, 17, 34, 170, 255, 10, 13, 26]\n\nmy kingdom for a horse\n['MY', 'KINGDOM', 'FOR', 'A', 'HORSE']\n\nnow is the winter of our discontent made glorious summer by this sun of york\n['Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York']\n</code></pre>\n", "signature": "(func, *args)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_common", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common", "type": "class", "doc": "<p>Here are some common low-level expressions that may be useful in\njump-starting parser development:</p>\n\n<ul>\n<li>numeric forms (<code>integers&lt;integer&gt;</code>, <code>reals&lt;real&gt;</code>,\n<code>scientific notation&lt;sci_real&gt;</code>)</li>\n<li>common <code>programming identifiers&lt;identifier&gt;</code></li>\n<li>network addresses (<code>MAC&lt;mac_address&gt;</code>,\n<code>IPv4&lt;ipv4_address&gt;</code>, <code>IPv6&lt;ipv6_address&gt;</code>)</li>\n<li>ISO8601 <code>dates&lt;iso8601_date&gt;</code> and\n<code>datetime&lt;iso8601_datetime&gt;</code></li>\n<li><code>UUID&lt;uuid&gt;</code></li>\n<li><code>comma-separated list&lt;comma_separated_list&gt;</code></li>\n</ul>\n\n<p>Parse actions:</p>\n\n<ul>\n<li><code>convertToInteger</code></li>\n<li><code>convertToFloat</code></li>\n<li><code>convertToDate</code></li>\n<li><code>convertToDatetime</code></li>\n<li><code>stripHTMLTags</code></li>\n<li><code>upcaseTokens</code></li>\n<li><code>downcaseTokens</code></li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code>pyparsing_common.number.runTests('''\n    # any int or real number, returned as the appropriate type\n    100\n    -100\n    +100\n    3.14159\n    6.02e23\n    1e-12\n    ''')\n\npyparsing_common.fnumber.runTests('''\n    # any int or real number, returned as float\n    100\n    -100\n    +100\n    3.14159\n    6.02e23\n    1e-12\n    ''')\n\npyparsing_common.hex_integer.runTests('''\n    # hex numbers\n    100\n    FF\n    ''')\n\npyparsing_common.fraction.runTests('''\n    # fractions\n    1/2\n    -3/4\n    ''')\n\npyparsing_common.mixed_integer.runTests('''\n    # mixed fractions\n    1\n    1/2\n    -3/4\n    1-3/4\n    ''')\n\nimport uuid\npyparsing_common.uuid.setParseAction(tokenMap(uuid.UUID))\npyparsing_common.uuid.runTests('''\n    # uuid\n    12345678-1234-5678-1234-567812345678\n    ''')\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code># any int or real number, returned as the appropriate type\n100\n[100]\n\n-100\n[-100]\n\n+100\n[100]\n\n3.14159\n[3.14159]\n\n6.02e23\n[6.02e+23]\n\n1e-12\n[1e-12]\n\n# any int or real number, returned as float\n100\n[100.0]\n\n-100\n[-100.0]\n\n+100\n[100.0]\n\n3.14159\n[3.14159]\n\n6.02e23\n[6.02e+23]\n\n1e-12\n[1e-12]\n\n# hex numbers\n100\n[256]\n\nFF\n[255]\n\n# fractions\n1/2\n[0.5]\n\n-3/4\n[-0.75]\n\n# mixed fractions\n1\n[1]\n\n1/2\n[0.5]\n\n-3/4\n[-0.75]\n\n1-3/4\n[1.75]\n\n# uuid\n12345678-1234-5678-1234-567812345678\n[UUID('12345678-1234-5678-1234-567812345678')]\n</code></pre>\n"}, {"fullname": "x4i.pyparsing.pyparsing_common.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_common.convertToInteger", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.convertToInteger", "type": "function", "doc": "<p>Parse action for converting parsed integers to Python int</p>\n", "signature": "(s, l, t)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_common.convertToFloat", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.convertToFloat", "type": "function", "doc": "<p>Parse action for converting parsed numbers to Python float</p>\n", "signature": "(s, l, t)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_common.integer", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.integer", "type": "variable", "doc": "<p>expression that parses an unsigned integer, returns an int</p>\n", "default_value": " = integer"}, {"fullname": "x4i.pyparsing.pyparsing_common.hex_integer", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.hex_integer", "type": "variable", "doc": "<p>expression that parses a hexadecimal integer, returns an int</p>\n", "default_value": " = hex integer"}, {"fullname": "x4i.pyparsing.pyparsing_common.signed_integer", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.signed_integer", "type": "variable", "doc": "<p>expression that parses an integer with optional leading sign, returns an int</p>\n", "default_value": " = signed integer"}, {"fullname": "x4i.pyparsing.pyparsing_common.fraction", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.fraction", "type": "variable", "doc": "<p>fractional expression of an integer divided by an integer, returns a float</p>\n", "default_value": " = fraction"}, {"fullname": "x4i.pyparsing.pyparsing_common.mixed_integer", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.mixed_integer", "type": "variable", "doc": "<p>mixed integer of the form 'integer - fraction', with optional leading integer, returns float</p>\n", "default_value": " = fraction or mixed integer-fraction"}, {"fullname": "x4i.pyparsing.pyparsing_common.real", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.real", "type": "variable", "doc": "<p>expression that parses a floating point number and returns a float</p>\n", "default_value": " = real number"}, {"fullname": "x4i.pyparsing.pyparsing_common.sci_real", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.sci_real", "type": "variable", "doc": "<p>expression that parses a floating point number with optional\nscientific notation and returns a float</p>\n", "default_value": " = real number with scientific notation"}, {"fullname": "x4i.pyparsing.pyparsing_common.number", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.number", "type": "variable", "doc": "<p>any numeric expression, returns the corresponding Python type</p>\n", "default_value": " = {real number with scientific notation | real number | signed integer}"}, {"fullname": "x4i.pyparsing.pyparsing_common.fnumber", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.fnumber", "type": "variable", "doc": "<p>any int or real number, returned as float</p>\n", "default_value": " = fnumber"}, {"fullname": "x4i.pyparsing.pyparsing_common.identifier", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.identifier", "type": "variable", "doc": "<p>typical code identifier (leading alpha or '_', followed by 0 or more alphas, nums, or '_')</p>\n", "default_value": " = identifier"}, {"fullname": "x4i.pyparsing.pyparsing_common.ipv4_address", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.ipv4_address", "type": "variable", "doc": "<p>IPv4 address (<code>0.0.0.0 - 255.255.255.255</code>)</p>\n", "default_value": " = IPv4 address"}, {"fullname": "x4i.pyparsing.pyparsing_common.ipv6_address", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.ipv6_address", "type": "variable", "doc": "<p>IPv6 address (long, short, or mixed form)</p>\n", "default_value": " = IPv6 address"}, {"fullname": "x4i.pyparsing.pyparsing_common.mac_address", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.mac_address", "type": "variable", "doc": "<p>MAC address xx:xx:xx:xx:xx (may also have '-' or '.' delimiters)</p>\n", "default_value": " = MAC address"}, {"fullname": "x4i.pyparsing.pyparsing_common.convertToDate", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.convertToDate", "type": "function", "doc": "<p>Helper to create a parse action for converting parsed date string to Python datetime.date</p>\n\n<p>Params -</p>\n\n<ul>\n<li>fmt - format to be passed to datetime.strptime (default= <code>\"%Y-%m-%d\"</code>)</li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code>date_expr = pyparsing_common.iso8601_date.copy()\ndate_expr.setParseAction(pyparsing_common.convertToDate())\nprint(date_expr.parseString(\"1999-12-31\"))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>[datetime.date(1999, 12, 31)]\n</code></pre>\n", "signature": "(fmt='%Y-%m-%d')", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_common.convertToDatetime", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.convertToDatetime", "type": "function", "doc": "<p>Helper to create a parse action for converting parsed\ndatetime string to Python datetime.datetime</p>\n\n<p>Params -</p>\n\n<ul>\n<li>fmt - format to be passed to datetime.strptime (default= <code>\"%Y-%m-%dT%H:%M:%S.%f\"</code>)</li>\n</ul>\n\n<p>Example::</p>\n\n<pre><code>dt_expr = pyparsing_common.iso8601_datetime.copy()\ndt_expr.setParseAction(pyparsing_common.convertToDatetime())\nprint(dt_expr.parseString(\"1999-12-31T23:59:59.999\"))\n</code></pre>\n\n<p>prints::</p>\n\n<pre><code>[datetime.datetime(1999, 12, 31, 23, 59, 59, 999000)]\n</code></pre>\n", "signature": "(fmt='%Y-%m-%dT%H:%M:%S.%f')", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_common.iso8601_date", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.iso8601_date", "type": "variable", "doc": "<p>ISO8601 date (<code>yyyy-mm-dd</code>)</p>\n", "default_value": " = ISO8601 date"}, {"fullname": "x4i.pyparsing.pyparsing_common.iso8601_datetime", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.iso8601_datetime", "type": "variable", "doc": "<p>ISO8601 datetime (<code>yyyy-mm-ddThh:mm:ss.s(Z|+-00:00)</code>) - trailing seconds, milliseconds, and timezone optional; accepts separating <code>'T'</code> or <code>' '</code></p>\n", "default_value": " = ISO8601 datetime"}, {"fullname": "x4i.pyparsing.pyparsing_common.uuid", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.uuid", "type": "variable", "doc": "<p>UUID (<code>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code>)</p>\n", "default_value": " = UUID"}, {"fullname": "x4i.pyparsing.pyparsing_common.stripHTMLTags", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.stripHTMLTags", "type": "function", "doc": "<p>Parse action to remove HTML tags from web page HTML source</p>\n\n<p>Example::</p>\n\n<pre><code># strip HTML links from normal text\ntext = '&lt;td&gt;More info at the &lt;a href=\"https://github.com/pyparsing/pyparsing/wiki\"&gt;pyparsing&lt;/a&gt; wiki page&lt;/td&gt;'\ntd,td_end = makeHTMLTags(\"TD\")\ntable_text = td + SkipTo(td_end).setParseAction(pyparsing_common.stripHTMLTags)(\"body\") + td_end\nprint(table_text.parseString(text).body)\n</code></pre>\n\n<p>Prints::</p>\n\n<pre><code>More info at the pyparsing wiki page\n</code></pre>\n", "signature": "(s, l, tokens)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_common.comma_separated_list", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.comma_separated_list", "type": "variable", "doc": "<p>Predefined expression of 1 or more printable words or quoted strings, separated by commas.</p>\n", "default_value": " = comma separated list"}, {"fullname": "x4i.pyparsing.pyparsing_common.upcaseTokens", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.upcaseTokens", "type": "function", "doc": "<p>Parse action to convert tokens to upper case.</p>\n", "signature": "(s, l, t)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_common.downcaseTokens", "modulename": "x4i.pyparsing", "qualname": "pyparsing_common.downcaseTokens", "type": "function", "doc": "<p>Parse action to convert tokens to lower case.</p>\n", "signature": "(s, l, t)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode", "type": "class", "doc": "<p>A namespace class for defining common language unicode_sets.</p>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Latin1", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Latin1", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Latin1.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Latin1.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.LatinA", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.LatinA", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.LatinA.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.LatinA.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.LatinB", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.LatinB", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.LatinB.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.LatinB.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Greek", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Greek", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Greek.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Greek.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Cyrillic", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Cyrillic", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Cyrillic.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Cyrillic.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Chinese", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Chinese", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Chinese.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Chinese.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Japanese", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Japanese", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Japanese.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Japanese.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Japanese.Kanji", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Japanese.Kanji", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Japanese.Kanji.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Japanese.Kanji.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Japanese.Hiragana", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Japanese.Hiragana", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Japanese.Hiragana.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Japanese.Hiragana.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Japanese.Katakana", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Japanese.Katakana", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Japanese.Katakana.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Japanese.Katakana.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Japanese.\u6f22\u5b57", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Japanese.\u6f22\u5b57", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Japanese.\u30ab\u30bf\u30ab\u30ca", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Japanese.\u30ab\u30bf\u30ab\u30ca", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Japanese.\u3072\u3089\u304c\u306a", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Japanese.\u3072\u3089\u304c\u306a", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Korean", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Korean", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Korean.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Korean.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.CJK", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.CJK", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "pyparsing_unicode.Chinese, pyparsing_unicode.Japanese, pyparsing_unicode.Korean"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.CJK.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.CJK.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Thai", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Thai", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Thai.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Thai.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Arabic", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Arabic", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Arabic.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Arabic.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Hebrew", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Hebrew", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Hebrew.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Hebrew.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Devanagari", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Devanagari", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.Devanagari.__init__", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.Devanagari.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.\u0627\u0644\u0639\u0631\u0628\u064a\u0629", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.\u0627\u0644\u0639\u0631\u0628\u064a\u0629", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.\u4e2d\u6587", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.\u4e2d\u6587", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.\u043a\u0438\u0440\u0438\u043b\u043b\u0438\u0446\u0430", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.\u043a\u0438\u0440\u0438\u043b\u043b\u0438\u0446\u0430", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.\u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.\u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.\u05e2\u05b4\u05d1\u05e8\u05b4\u05d9\u05ea", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.\u05e2\u05b4\u05d1\u05e8\u05b4\u05d9\u05ea", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.\u65e5\u672c\u8a9e", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.\u65e5\u672c\u8a9e", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.\ud55c\uad6d\uc5b4", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.\ud55c\uad6d\uc5b4", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.\u0e44\u0e17\u0e22", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.\u0e44\u0e17\u0e22", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.pyparsing_unicode.\u0926\u0947\u0935\u0928\u093e\u0917\u0930\u0940", "modulename": "x4i.pyparsing", "qualname": "pyparsing_unicode.\u0926\u0947\u0935\u0928\u093e\u0917\u0930\u0940", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n", "bases": "unicode_set"}, {"fullname": "x4i.pyparsing.unicode_set", "modulename": "x4i.pyparsing", "qualname": "unicode_set", "type": "class", "doc": "<p>A set of Unicode characters, for language-specific strings for\n<code>alphas</code>, <code>nums</code>, <code>alphanums</code>, and <code>printables</code>.\nA unicode_set is defined by a list of ranges in the Unicode character\nset, in a class attribute <code>_ranges</code>, such as::</p>\n\n<pre><code>_ranges = [(0x0020, 0x007e), (0x00a0, 0x00ff),]\n</code></pre>\n\n<p>A unicode set can also be defined using multiple inheritance of other unicode sets::</p>\n\n<pre><code>class CJK(Chinese, Japanese, Korean):\n    pass\n</code></pre>\n"}, {"fullname": "x4i.pyparsing.unicode_set.__init__", "modulename": "x4i.pyparsing", "qualname": "unicode_set.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "x4i.pyparsing.unicode_set.printables", "modulename": "x4i.pyparsing", "qualname": "unicode_set.printables", "type": "function", "doc": "<p>str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str</p>\n\n<p>Create a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.unicode_set.alphas", "modulename": "x4i.pyparsing", "qualname": "unicode_set.alphas", "type": "function", "doc": "<p>str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str</p>\n\n<p>Create a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.unicode_set.nums", "modulename": "x4i.pyparsing", "qualname": "unicode_set.nums", "type": "function", "doc": "<p>str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str</p>\n\n<p>Create a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.</p>\n", "signature": "(unknown)", "funcdef": "def"}, {"fullname": "x4i.pyparsing.unicode_set.alphanums", "modulename": "x4i.pyparsing", "qualname": "unicode_set.alphanums", "type": "function", "doc": "<p>str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str</p>\n\n<p>Create a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.</p>\n", "signature": "(unknown)", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();